// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"genomedb/ent/genome"
	"genomedb/ent/locus"
	"genomedb/ent/predicate"
	"genomedb/ent/scaffold"
	"genomedb/ent/transcript"
	"genomedb/gffio"
	"sync"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeGenome     = "Genome"
	TypeLocus      = "Locus"
	TypeScaffold   = "Scaffold"
	TypeTranscript = "Transcript"
)

// GenomeMutation represents an operation that mutates the Genome nodes in the graph.
type GenomeMutation struct {
	config
	op               Op
	typ              string
	id               *string
	codon_table      *int32
	addcodon_table   *int32
	clearedFields    map[string]struct{}
	locuses          map[string]struct{}
	removedlocuses   map[string]struct{}
	clearedlocuses   bool
	scaffolds        map[int]struct{}
	removedscaffolds map[int]struct{}
	clearedscaffolds bool
	done             bool
	oldValue         func(context.Context) (*Genome, error)
	predicates       []predicate.Genome
}

var _ ent.Mutation = (*GenomeMutation)(nil)

// genomeOption allows management of the mutation configuration using functional options.
type genomeOption func(*GenomeMutation)

// newGenomeMutation creates new mutation for the Genome entity.
func newGenomeMutation(c config, op Op, opts ...genomeOption) *GenomeMutation {
	m := &GenomeMutation{
		config:        c,
		op:            op,
		typ:           TypeGenome,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenomeID sets the ID field of the mutation.
func withGenomeID(id string) genomeOption {
	return func(m *GenomeMutation) {
		var (
			err   error
			once  sync.Once
			value *Genome
		)
		m.oldValue = func(ctx context.Context) (*Genome, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Genome.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGenome sets the old Genome of the mutation.
func withGenome(node *Genome) genomeOption {
	return func(m *GenomeMutation) {
		m.oldValue = func(context.Context) (*Genome, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenomeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenomeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Genome entities.
func (m *GenomeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GenomeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GenomeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Genome.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCodonTable sets the "codon_table" field.
func (m *GenomeMutation) SetCodonTable(i int32) {
	m.codon_table = &i
	m.addcodon_table = nil
}

// CodonTable returns the value of the "codon_table" field in the mutation.
func (m *GenomeMutation) CodonTable() (r int32, exists bool) {
	v := m.codon_table
	if v == nil {
		return
	}
	return *v, true
}

// OldCodonTable returns the old "codon_table" field's value of the Genome entity.
// If the Genome object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenomeMutation) OldCodonTable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodonTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodonTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodonTable: %w", err)
	}
	return oldValue.CodonTable, nil
}

// AddCodonTable adds i to the "codon_table" field.
func (m *GenomeMutation) AddCodonTable(i int32) {
	if m.addcodon_table != nil {
		*m.addcodon_table += i
	} else {
		m.addcodon_table = &i
	}
}

// AddedCodonTable returns the value that was added to the "codon_table" field in this mutation.
func (m *GenomeMutation) AddedCodonTable() (r int32, exists bool) {
	v := m.addcodon_table
	if v == nil {
		return
	}
	return *v, true
}

// ResetCodonTable resets all changes to the "codon_table" field.
func (m *GenomeMutation) ResetCodonTable() {
	m.codon_table = nil
	m.addcodon_table = nil
}

// AddLocuseIDs adds the "locuses" edge to the Locus entity by ids.
func (m *GenomeMutation) AddLocuseIDs(ids ...string) {
	if m.locuses == nil {
		m.locuses = make(map[string]struct{})
	}
	for i := range ids {
		m.locuses[ids[i]] = struct{}{}
	}
}

// ClearLocuses clears the "locuses" edge to the Locus entity.
func (m *GenomeMutation) ClearLocuses() {
	m.clearedlocuses = true
}

// LocusesCleared reports if the "locuses" edge to the Locus entity was cleared.
func (m *GenomeMutation) LocusesCleared() bool {
	return m.clearedlocuses
}

// RemoveLocuseIDs removes the "locuses" edge to the Locus entity by IDs.
func (m *GenomeMutation) RemoveLocuseIDs(ids ...string) {
	if m.removedlocuses == nil {
		m.removedlocuses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.locuses, ids[i])
		m.removedlocuses[ids[i]] = struct{}{}
	}
}

// RemovedLocuses returns the removed IDs of the "locuses" edge to the Locus entity.
func (m *GenomeMutation) RemovedLocusesIDs() (ids []string) {
	for id := range m.removedlocuses {
		ids = append(ids, id)
	}
	return
}

// LocusesIDs returns the "locuses" edge IDs in the mutation.
func (m *GenomeMutation) LocusesIDs() (ids []string) {
	for id := range m.locuses {
		ids = append(ids, id)
	}
	return
}

// ResetLocuses resets all changes to the "locuses" edge.
func (m *GenomeMutation) ResetLocuses() {
	m.locuses = nil
	m.clearedlocuses = false
	m.removedlocuses = nil
}

// AddScaffoldIDs adds the "scaffolds" edge to the Scaffold entity by ids.
func (m *GenomeMutation) AddScaffoldIDs(ids ...int) {
	if m.scaffolds == nil {
		m.scaffolds = make(map[int]struct{})
	}
	for i := range ids {
		m.scaffolds[ids[i]] = struct{}{}
	}
}

// ClearScaffolds clears the "scaffolds" edge to the Scaffold entity.
func (m *GenomeMutation) ClearScaffolds() {
	m.clearedscaffolds = true
}

// ScaffoldsCleared reports if the "scaffolds" edge to the Scaffold entity was cleared.
func (m *GenomeMutation) ScaffoldsCleared() bool {
	return m.clearedscaffolds
}

// RemoveScaffoldIDs removes the "scaffolds" edge to the Scaffold entity by IDs.
func (m *GenomeMutation) RemoveScaffoldIDs(ids ...int) {
	if m.removedscaffolds == nil {
		m.removedscaffolds = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scaffolds, ids[i])
		m.removedscaffolds[ids[i]] = struct{}{}
	}
}

// RemovedScaffolds returns the removed IDs of the "scaffolds" edge to the Scaffold entity.
func (m *GenomeMutation) RemovedScaffoldsIDs() (ids []int) {
	for id := range m.removedscaffolds {
		ids = append(ids, id)
	}
	return
}

// ScaffoldsIDs returns the "scaffolds" edge IDs in the mutation.
func (m *GenomeMutation) ScaffoldsIDs() (ids []int) {
	for id := range m.scaffolds {
		ids = append(ids, id)
	}
	return
}

// ResetScaffolds resets all changes to the "scaffolds" edge.
func (m *GenomeMutation) ResetScaffolds() {
	m.scaffolds = nil
	m.clearedscaffolds = false
	m.removedscaffolds = nil
}

// Where appends a list predicates to the GenomeMutation builder.
func (m *GenomeMutation) Where(ps ...predicate.Genome) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GenomeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Genome).
func (m *GenomeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenomeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.codon_table != nil {
		fields = append(fields, genome.FieldCodonTable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenomeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case genome.FieldCodonTable:
		return m.CodonTable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenomeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case genome.FieldCodonTable:
		return m.OldCodonTable(ctx)
	}
	return nil, fmt.Errorf("unknown Genome field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenomeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case genome.FieldCodonTable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodonTable(v)
		return nil
	}
	return fmt.Errorf("unknown Genome field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenomeMutation) AddedFields() []string {
	var fields []string
	if m.addcodon_table != nil {
		fields = append(fields, genome.FieldCodonTable)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenomeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case genome.FieldCodonTable:
		return m.AddedCodonTable()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenomeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case genome.FieldCodonTable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCodonTable(v)
		return nil
	}
	return fmt.Errorf("unknown Genome numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenomeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenomeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenomeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Genome nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenomeMutation) ResetField(name string) error {
	switch name {
	case genome.FieldCodonTable:
		m.ResetCodonTable()
		return nil
	}
	return fmt.Errorf("unknown Genome field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenomeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.locuses != nil {
		edges = append(edges, genome.EdgeLocuses)
	}
	if m.scaffolds != nil {
		edges = append(edges, genome.EdgeScaffolds)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenomeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case genome.EdgeLocuses:
		ids := make([]ent.Value, 0, len(m.locuses))
		for id := range m.locuses {
			ids = append(ids, id)
		}
		return ids
	case genome.EdgeScaffolds:
		ids := make([]ent.Value, 0, len(m.scaffolds))
		for id := range m.scaffolds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenomeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedlocuses != nil {
		edges = append(edges, genome.EdgeLocuses)
	}
	if m.removedscaffolds != nil {
		edges = append(edges, genome.EdgeScaffolds)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenomeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case genome.EdgeLocuses:
		ids := make([]ent.Value, 0, len(m.removedlocuses))
		for id := range m.removedlocuses {
			ids = append(ids, id)
		}
		return ids
	case genome.EdgeScaffolds:
		ids := make([]ent.Value, 0, len(m.removedscaffolds))
		for id := range m.removedscaffolds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenomeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlocuses {
		edges = append(edges, genome.EdgeLocuses)
	}
	if m.clearedscaffolds {
		edges = append(edges, genome.EdgeScaffolds)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenomeMutation) EdgeCleared(name string) bool {
	switch name {
	case genome.EdgeLocuses:
		return m.clearedlocuses
	case genome.EdgeScaffolds:
		return m.clearedscaffolds
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenomeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Genome unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenomeMutation) ResetEdge(name string) error {
	switch name {
	case genome.EdgeLocuses:
		m.ResetLocuses()
		return nil
	case genome.EdgeScaffolds:
		m.ResetScaffolds()
		return nil
	}
	return fmt.Errorf("unknown Genome edge %s", name)
}

// LocusMutation represents an operation that mutates the Locus nodes in the graph.
type LocusMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	clearedFields      map[string]struct{}
	transcripts        map[string]struct{}
	removedtranscripts map[string]struct{}
	clearedtranscripts bool
	genome             *string
	clearedgenome      bool
	done               bool
	oldValue           func(context.Context) (*Locus, error)
	predicates         []predicate.Locus
}

var _ ent.Mutation = (*LocusMutation)(nil)

// locusOption allows management of the mutation configuration using functional options.
type locusOption func(*LocusMutation)

// newLocusMutation creates new mutation for the Locus entity.
func newLocusMutation(c config, op Op, opts ...locusOption) *LocusMutation {
	m := &LocusMutation{
		config:        c,
		op:            op,
		typ:           TypeLocus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocusID sets the ID field of the mutation.
func withLocusID(id string) locusOption {
	return func(m *LocusMutation) {
		var (
			err   error
			once  sync.Once
			value *Locus
		)
		m.oldValue = func(ctx context.Context) (*Locus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Locus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocus sets the old Locus of the mutation.
func withLocus(node *Locus) locusOption {
	return func(m *LocusMutation) {
		m.oldValue = func(context.Context) (*Locus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Locus entities.
func (m *LocusMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocusMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocusMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Locus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddTranscriptIDs adds the "transcripts" edge to the Transcript entity by ids.
func (m *LocusMutation) AddTranscriptIDs(ids ...string) {
	if m.transcripts == nil {
		m.transcripts = make(map[string]struct{})
	}
	for i := range ids {
		m.transcripts[ids[i]] = struct{}{}
	}
}

// ClearTranscripts clears the "transcripts" edge to the Transcript entity.
func (m *LocusMutation) ClearTranscripts() {
	m.clearedtranscripts = true
}

// TranscriptsCleared reports if the "transcripts" edge to the Transcript entity was cleared.
func (m *LocusMutation) TranscriptsCleared() bool {
	return m.clearedtranscripts
}

// RemoveTranscriptIDs removes the "transcripts" edge to the Transcript entity by IDs.
func (m *LocusMutation) RemoveTranscriptIDs(ids ...string) {
	if m.removedtranscripts == nil {
		m.removedtranscripts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transcripts, ids[i])
		m.removedtranscripts[ids[i]] = struct{}{}
	}
}

// RemovedTranscripts returns the removed IDs of the "transcripts" edge to the Transcript entity.
func (m *LocusMutation) RemovedTranscriptsIDs() (ids []string) {
	for id := range m.removedtranscripts {
		ids = append(ids, id)
	}
	return
}

// TranscriptsIDs returns the "transcripts" edge IDs in the mutation.
func (m *LocusMutation) TranscriptsIDs() (ids []string) {
	for id := range m.transcripts {
		ids = append(ids, id)
	}
	return
}

// ResetTranscripts resets all changes to the "transcripts" edge.
func (m *LocusMutation) ResetTranscripts() {
	m.transcripts = nil
	m.clearedtranscripts = false
	m.removedtranscripts = nil
}

// SetGenomeID sets the "genome" edge to the Genome entity by id.
func (m *LocusMutation) SetGenomeID(id string) {
	m.genome = &id
}

// ClearGenome clears the "genome" edge to the Genome entity.
func (m *LocusMutation) ClearGenome() {
	m.clearedgenome = true
}

// GenomeCleared reports if the "genome" edge to the Genome entity was cleared.
func (m *LocusMutation) GenomeCleared() bool {
	return m.clearedgenome
}

// GenomeID returns the "genome" edge ID in the mutation.
func (m *LocusMutation) GenomeID() (id string, exists bool) {
	if m.genome != nil {
		return *m.genome, true
	}
	return
}

// GenomeIDs returns the "genome" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenomeID instead. It exists only for internal usage by the builders.
func (m *LocusMutation) GenomeIDs() (ids []string) {
	if id := m.genome; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenome resets all changes to the "genome" edge.
func (m *LocusMutation) ResetGenome() {
	m.genome = nil
	m.clearedgenome = false
}

// Where appends a list predicates to the LocusMutation builder.
func (m *LocusMutation) Where(ps ...predicate.Locus) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LocusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Locus).
func (m *LocusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocusMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocusMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Locus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocusMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Locus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocusMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Locus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Locus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocusMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Locus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocusMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.transcripts != nil {
		edges = append(edges, locus.EdgeTranscripts)
	}
	if m.genome != nil {
		edges = append(edges, locus.EdgeGenome)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case locus.EdgeTranscripts:
		ids := make([]ent.Value, 0, len(m.transcripts))
		for id := range m.transcripts {
			ids = append(ids, id)
		}
		return ids
	case locus.EdgeGenome:
		if id := m.genome; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtranscripts != nil {
		edges = append(edges, locus.EdgeTranscripts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case locus.EdgeTranscripts:
		ids := make([]ent.Value, 0, len(m.removedtranscripts))
		for id := range m.removedtranscripts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtranscripts {
		edges = append(edges, locus.EdgeTranscripts)
	}
	if m.clearedgenome {
		edges = append(edges, locus.EdgeGenome)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocusMutation) EdgeCleared(name string) bool {
	switch name {
	case locus.EdgeTranscripts:
		return m.clearedtranscripts
	case locus.EdgeGenome:
		return m.clearedgenome
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocusMutation) ClearEdge(name string) error {
	switch name {
	case locus.EdgeGenome:
		m.ClearGenome()
		return nil
	}
	return fmt.Errorf("unknown Locus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocusMutation) ResetEdge(name string) error {
	switch name {
	case locus.EdgeTranscripts:
		m.ResetTranscripts()
		return nil
	case locus.EdgeGenome:
		m.ResetGenome()
		return nil
	}
	return fmt.Errorf("unknown Locus edge %s", name)
}

// ScaffoldMutation represents an operation that mutates the Scaffold nodes in the graph.
type ScaffoldMutation struct {
	config
	op            Op
	typ           string
	id            *int
	seqname       *string
	seq           *string
	clearedFields map[string]struct{}
	genome        *string
	clearedgenome bool
	done          bool
	oldValue      func(context.Context) (*Scaffold, error)
	predicates    []predicate.Scaffold
}

var _ ent.Mutation = (*ScaffoldMutation)(nil)

// scaffoldOption allows management of the mutation configuration using functional options.
type scaffoldOption func(*ScaffoldMutation)

// newScaffoldMutation creates new mutation for the Scaffold entity.
func newScaffoldMutation(c config, op Op, opts ...scaffoldOption) *ScaffoldMutation {
	m := &ScaffoldMutation{
		config:        c,
		op:            op,
		typ:           TypeScaffold,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScaffoldID sets the ID field of the mutation.
func withScaffoldID(id int) scaffoldOption {
	return func(m *ScaffoldMutation) {
		var (
			err   error
			once  sync.Once
			value *Scaffold
		)
		m.oldValue = func(ctx context.Context) (*Scaffold, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scaffold.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScaffold sets the old Scaffold of the mutation.
func withScaffold(node *Scaffold) scaffoldOption {
	return func(m *ScaffoldMutation) {
		m.oldValue = func(context.Context) (*Scaffold, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScaffoldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScaffoldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScaffoldMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScaffoldMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Scaffold.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeqname sets the "seqname" field.
func (m *ScaffoldMutation) SetSeqname(s string) {
	m.seqname = &s
}

// Seqname returns the value of the "seqname" field in the mutation.
func (m *ScaffoldMutation) Seqname() (r string, exists bool) {
	v := m.seqname
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqname returns the old "seqname" field's value of the Scaffold entity.
// If the Scaffold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScaffoldMutation) OldSeqname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeqname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeqname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqname: %w", err)
	}
	return oldValue.Seqname, nil
}

// ResetSeqname resets all changes to the "seqname" field.
func (m *ScaffoldMutation) ResetSeqname() {
	m.seqname = nil
}

// SetSeq sets the "seq" field.
func (m *ScaffoldMutation) SetSeq(s string) {
	m.seq = &s
}

// Seq returns the value of the "seq" field in the mutation.
func (m *ScaffoldMutation) Seq() (r string, exists bool) {
	v := m.seq
	if v == nil {
		return
	}
	return *v, true
}

// OldSeq returns the old "seq" field's value of the Scaffold entity.
// If the Scaffold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScaffoldMutation) OldSeq(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeq is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeq requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeq: %w", err)
	}
	return oldValue.Seq, nil
}

// ResetSeq resets all changes to the "seq" field.
func (m *ScaffoldMutation) ResetSeq() {
	m.seq = nil
}

// SetGenomeID sets the "genome" edge to the Genome entity by id.
func (m *ScaffoldMutation) SetGenomeID(id string) {
	m.genome = &id
}

// ClearGenome clears the "genome" edge to the Genome entity.
func (m *ScaffoldMutation) ClearGenome() {
	m.clearedgenome = true
}

// GenomeCleared reports if the "genome" edge to the Genome entity was cleared.
func (m *ScaffoldMutation) GenomeCleared() bool {
	return m.clearedgenome
}

// GenomeID returns the "genome" edge ID in the mutation.
func (m *ScaffoldMutation) GenomeID() (id string, exists bool) {
	if m.genome != nil {
		return *m.genome, true
	}
	return
}

// GenomeIDs returns the "genome" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenomeID instead. It exists only for internal usage by the builders.
func (m *ScaffoldMutation) GenomeIDs() (ids []string) {
	if id := m.genome; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenome resets all changes to the "genome" edge.
func (m *ScaffoldMutation) ResetGenome() {
	m.genome = nil
	m.clearedgenome = false
}

// Where appends a list predicates to the ScaffoldMutation builder.
func (m *ScaffoldMutation) Where(ps ...predicate.Scaffold) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ScaffoldMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Scaffold).
func (m *ScaffoldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScaffoldMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.seqname != nil {
		fields = append(fields, scaffold.FieldSeqname)
	}
	if m.seq != nil {
		fields = append(fields, scaffold.FieldSeq)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScaffoldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scaffold.FieldSeqname:
		return m.Seqname()
	case scaffold.FieldSeq:
		return m.Seq()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScaffoldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scaffold.FieldSeqname:
		return m.OldSeqname(ctx)
	case scaffold.FieldSeq:
		return m.OldSeq(ctx)
	}
	return nil, fmt.Errorf("unknown Scaffold field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScaffoldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scaffold.FieldSeqname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqname(v)
		return nil
	case scaffold.FieldSeq:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeq(v)
		return nil
	}
	return fmt.Errorf("unknown Scaffold field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScaffoldMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScaffoldMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScaffoldMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Scaffold numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScaffoldMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScaffoldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScaffoldMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Scaffold nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScaffoldMutation) ResetField(name string) error {
	switch name {
	case scaffold.FieldSeqname:
		m.ResetSeqname()
		return nil
	case scaffold.FieldSeq:
		m.ResetSeq()
		return nil
	}
	return fmt.Errorf("unknown Scaffold field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScaffoldMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.genome != nil {
		edges = append(edges, scaffold.EdgeGenome)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScaffoldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scaffold.EdgeGenome:
		if id := m.genome; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScaffoldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScaffoldMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScaffoldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgenome {
		edges = append(edges, scaffold.EdgeGenome)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScaffoldMutation) EdgeCleared(name string) bool {
	switch name {
	case scaffold.EdgeGenome:
		return m.clearedgenome
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScaffoldMutation) ClearEdge(name string) error {
	switch name {
	case scaffold.EdgeGenome:
		m.ClearGenome()
		return nil
	}
	return fmt.Errorf("unknown Scaffold unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScaffoldMutation) ResetEdge(name string) error {
	switch name {
	case scaffold.EdgeGenome:
		m.ResetGenome()
		return nil
	}
	return fmt.Errorf("unknown Scaffold edge %s", name)
}

// TranscriptMutation represents an operation that mutates the Transcript nodes in the graph.
type TranscriptMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	seqname               *string
	strand                *string
	_type                 *string
	start                 *int32
	addstart              *int32
	end                   *int32
	addend                *int32
	exon                  *[]gffio.GffRecord
	appendexon            []gffio.GffRecord
	five_prime_utr        *[]gffio.GffRecord
	appendfive_prime_utr  []gffio.GffRecord
	three_prime_utr       *[]gffio.GffRecord
	appendthree_prime_utr []gffio.GffRecord
	cds                   *[]gffio.GffRecord
	appendcds             []gffio.GffRecord
	genomic_sequence      *string
	exon_sequence         *string
	cds_sequence          *string
	protein_sequence      *string
	clearedFields         map[string]struct{}
	locus                 *string
	clearedlocus          bool
	done                  bool
	oldValue              func(context.Context) (*Transcript, error)
	predicates            []predicate.Transcript
}

var _ ent.Mutation = (*TranscriptMutation)(nil)

// transcriptOption allows management of the mutation configuration using functional options.
type transcriptOption func(*TranscriptMutation)

// newTranscriptMutation creates new mutation for the Transcript entity.
func newTranscriptMutation(c config, op Op, opts ...transcriptOption) *TranscriptMutation {
	m := &TranscriptMutation{
		config:        c,
		op:            op,
		typ:           TypeTranscript,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTranscriptID sets the ID field of the mutation.
func withTranscriptID(id string) transcriptOption {
	return func(m *TranscriptMutation) {
		var (
			err   error
			once  sync.Once
			value *Transcript
		)
		m.oldValue = func(ctx context.Context) (*Transcript, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transcript.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTranscript sets the old Transcript of the mutation.
func withTranscript(node *Transcript) transcriptOption {
	return func(m *TranscriptMutation) {
		m.oldValue = func(context.Context) (*Transcript, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TranscriptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TranscriptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transcript entities.
func (m *TranscriptMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TranscriptMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TranscriptMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transcript.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeqname sets the "seqname" field.
func (m *TranscriptMutation) SetSeqname(s string) {
	m.seqname = &s
}

// Seqname returns the value of the "seqname" field in the mutation.
func (m *TranscriptMutation) Seqname() (r string, exists bool) {
	v := m.seqname
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqname returns the old "seqname" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldSeqname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeqname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeqname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqname: %w", err)
	}
	return oldValue.Seqname, nil
}

// ResetSeqname resets all changes to the "seqname" field.
func (m *TranscriptMutation) ResetSeqname() {
	m.seqname = nil
}

// SetStrand sets the "strand" field.
func (m *TranscriptMutation) SetStrand(s string) {
	m.strand = &s
}

// Strand returns the value of the "strand" field in the mutation.
func (m *TranscriptMutation) Strand() (r string, exists bool) {
	v := m.strand
	if v == nil {
		return
	}
	return *v, true
}

// OldStrand returns the old "strand" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldStrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrand: %w", err)
	}
	return oldValue.Strand, nil
}

// ResetStrand resets all changes to the "strand" field.
func (m *TranscriptMutation) ResetStrand() {
	m.strand = nil
}

// SetType sets the "type" field.
func (m *TranscriptMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TranscriptMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TranscriptMutation) ResetType() {
	m._type = nil
}

// SetStart sets the "start" field.
func (m *TranscriptMutation) SetStart(i int32) {
	m.start = &i
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *TranscriptMutation) Start() (r int32, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldStart(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds i to the "start" field.
func (m *TranscriptMutation) AddStart(i int32) {
	if m.addstart != nil {
		*m.addstart += i
	} else {
		m.addstart = &i
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *TranscriptMutation) AddedStart() (r int32, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *TranscriptMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *TranscriptMutation) SetEnd(i int32) {
	m.end = &i
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *TranscriptMutation) End() (r int32, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldEnd(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds i to the "end" field.
func (m *TranscriptMutation) AddEnd(i int32) {
	if m.addend != nil {
		*m.addend += i
	} else {
		m.addend = &i
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *TranscriptMutation) AddedEnd() (r int32, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *TranscriptMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetExon sets the "exon" field.
func (m *TranscriptMutation) SetExon(gr []gffio.GffRecord) {
	m.exon = &gr
	m.appendexon = nil
}

// Exon returns the value of the "exon" field in the mutation.
func (m *TranscriptMutation) Exon() (r []gffio.GffRecord, exists bool) {
	v := m.exon
	if v == nil {
		return
	}
	return *v, true
}

// OldExon returns the old "exon" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldExon(ctx context.Context) (v []gffio.GffRecord, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExon: %w", err)
	}
	return oldValue.Exon, nil
}

// AppendExon adds gr to the "exon" field.
func (m *TranscriptMutation) AppendExon(gr []gffio.GffRecord) {
	m.appendexon = append(m.appendexon, gr...)
}

// AppendedExon returns the list of values that were appended to the "exon" field in this mutation.
func (m *TranscriptMutation) AppendedExon() ([]gffio.GffRecord, bool) {
	if len(m.appendexon) == 0 {
		return nil, false
	}
	return m.appendexon, true
}

// ResetExon resets all changes to the "exon" field.
func (m *TranscriptMutation) ResetExon() {
	m.exon = nil
	m.appendexon = nil
}

// SetFivePrimeUtr sets the "five_prime_utr" field.
func (m *TranscriptMutation) SetFivePrimeUtr(gr []gffio.GffRecord) {
	m.five_prime_utr = &gr
	m.appendfive_prime_utr = nil
}

// FivePrimeUtr returns the value of the "five_prime_utr" field in the mutation.
func (m *TranscriptMutation) FivePrimeUtr() (r []gffio.GffRecord, exists bool) {
	v := m.five_prime_utr
	if v == nil {
		return
	}
	return *v, true
}

// OldFivePrimeUtr returns the old "five_prime_utr" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldFivePrimeUtr(ctx context.Context) (v []gffio.GffRecord, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFivePrimeUtr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFivePrimeUtr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFivePrimeUtr: %w", err)
	}
	return oldValue.FivePrimeUtr, nil
}

// AppendFivePrimeUtr adds gr to the "five_prime_utr" field.
func (m *TranscriptMutation) AppendFivePrimeUtr(gr []gffio.GffRecord) {
	m.appendfive_prime_utr = append(m.appendfive_prime_utr, gr...)
}

// AppendedFivePrimeUtr returns the list of values that were appended to the "five_prime_utr" field in this mutation.
func (m *TranscriptMutation) AppendedFivePrimeUtr() ([]gffio.GffRecord, bool) {
	if len(m.appendfive_prime_utr) == 0 {
		return nil, false
	}
	return m.appendfive_prime_utr, true
}

// ResetFivePrimeUtr resets all changes to the "five_prime_utr" field.
func (m *TranscriptMutation) ResetFivePrimeUtr() {
	m.five_prime_utr = nil
	m.appendfive_prime_utr = nil
}

// SetThreePrimeUtr sets the "three_prime_utr" field.
func (m *TranscriptMutation) SetThreePrimeUtr(gr []gffio.GffRecord) {
	m.three_prime_utr = &gr
	m.appendthree_prime_utr = nil
}

// ThreePrimeUtr returns the value of the "three_prime_utr" field in the mutation.
func (m *TranscriptMutation) ThreePrimeUtr() (r []gffio.GffRecord, exists bool) {
	v := m.three_prime_utr
	if v == nil {
		return
	}
	return *v, true
}

// OldThreePrimeUtr returns the old "three_prime_utr" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldThreePrimeUtr(ctx context.Context) (v []gffio.GffRecord, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreePrimeUtr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreePrimeUtr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreePrimeUtr: %w", err)
	}
	return oldValue.ThreePrimeUtr, nil
}

// AppendThreePrimeUtr adds gr to the "three_prime_utr" field.
func (m *TranscriptMutation) AppendThreePrimeUtr(gr []gffio.GffRecord) {
	m.appendthree_prime_utr = append(m.appendthree_prime_utr, gr...)
}

// AppendedThreePrimeUtr returns the list of values that were appended to the "three_prime_utr" field in this mutation.
func (m *TranscriptMutation) AppendedThreePrimeUtr() ([]gffio.GffRecord, bool) {
	if len(m.appendthree_prime_utr) == 0 {
		return nil, false
	}
	return m.appendthree_prime_utr, true
}

// ResetThreePrimeUtr resets all changes to the "three_prime_utr" field.
func (m *TranscriptMutation) ResetThreePrimeUtr() {
	m.three_prime_utr = nil
	m.appendthree_prime_utr = nil
}

// SetCds sets the "cds" field.
func (m *TranscriptMutation) SetCds(gr []gffio.GffRecord) {
	m.cds = &gr
	m.appendcds = nil
}

// Cds returns the value of the "cds" field in the mutation.
func (m *TranscriptMutation) Cds() (r []gffio.GffRecord, exists bool) {
	v := m.cds
	if v == nil {
		return
	}
	return *v, true
}

// OldCds returns the old "cds" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldCds(ctx context.Context) (v []gffio.GffRecord, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCds: %w", err)
	}
	return oldValue.Cds, nil
}

// AppendCds adds gr to the "cds" field.
func (m *TranscriptMutation) AppendCds(gr []gffio.GffRecord) {
	m.appendcds = append(m.appendcds, gr...)
}

// AppendedCds returns the list of values that were appended to the "cds" field in this mutation.
func (m *TranscriptMutation) AppendedCds() ([]gffio.GffRecord, bool) {
	if len(m.appendcds) == 0 {
		return nil, false
	}
	return m.appendcds, true
}

// ResetCds resets all changes to the "cds" field.
func (m *TranscriptMutation) ResetCds() {
	m.cds = nil
	m.appendcds = nil
}

// SetGenomicSequence sets the "genomic_sequence" field.
func (m *TranscriptMutation) SetGenomicSequence(s string) {
	m.genomic_sequence = &s
}

// GenomicSequence returns the value of the "genomic_sequence" field in the mutation.
func (m *TranscriptMutation) GenomicSequence() (r string, exists bool) {
	v := m.genomic_sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldGenomicSequence returns the old "genomic_sequence" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldGenomicSequence(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenomicSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenomicSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenomicSequence: %w", err)
	}
	return oldValue.GenomicSequence, nil
}

// ResetGenomicSequence resets all changes to the "genomic_sequence" field.
func (m *TranscriptMutation) ResetGenomicSequence() {
	m.genomic_sequence = nil
}

// SetExonSequence sets the "exon_sequence" field.
func (m *TranscriptMutation) SetExonSequence(s string) {
	m.exon_sequence = &s
}

// ExonSequence returns the value of the "exon_sequence" field in the mutation.
func (m *TranscriptMutation) ExonSequence() (r string, exists bool) {
	v := m.exon_sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldExonSequence returns the old "exon_sequence" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldExonSequence(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExonSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExonSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExonSequence: %w", err)
	}
	return oldValue.ExonSequence, nil
}

// ResetExonSequence resets all changes to the "exon_sequence" field.
func (m *TranscriptMutation) ResetExonSequence() {
	m.exon_sequence = nil
}

// SetCdsSequence sets the "cds_sequence" field.
func (m *TranscriptMutation) SetCdsSequence(s string) {
	m.cds_sequence = &s
}

// CdsSequence returns the value of the "cds_sequence" field in the mutation.
func (m *TranscriptMutation) CdsSequence() (r string, exists bool) {
	v := m.cds_sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldCdsSequence returns the old "cds_sequence" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldCdsSequence(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCdsSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCdsSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCdsSequence: %w", err)
	}
	return oldValue.CdsSequence, nil
}

// ResetCdsSequence resets all changes to the "cds_sequence" field.
func (m *TranscriptMutation) ResetCdsSequence() {
	m.cds_sequence = nil
}

// SetProteinSequence sets the "protein_sequence" field.
func (m *TranscriptMutation) SetProteinSequence(s string) {
	m.protein_sequence = &s
}

// ProteinSequence returns the value of the "protein_sequence" field in the mutation.
func (m *TranscriptMutation) ProteinSequence() (r string, exists bool) {
	v := m.protein_sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldProteinSequence returns the old "protein_sequence" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldProteinSequence(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProteinSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProteinSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProteinSequence: %w", err)
	}
	return oldValue.ProteinSequence, nil
}

// ResetProteinSequence resets all changes to the "protein_sequence" field.
func (m *TranscriptMutation) ResetProteinSequence() {
	m.protein_sequence = nil
}

// SetLocusID sets the "locus" edge to the Locus entity by id.
func (m *TranscriptMutation) SetLocusID(id string) {
	m.locus = &id
}

// ClearLocus clears the "locus" edge to the Locus entity.
func (m *TranscriptMutation) ClearLocus() {
	m.clearedlocus = true
}

// LocusCleared reports if the "locus" edge to the Locus entity was cleared.
func (m *TranscriptMutation) LocusCleared() bool {
	return m.clearedlocus
}

// LocusID returns the "locus" edge ID in the mutation.
func (m *TranscriptMutation) LocusID() (id string, exists bool) {
	if m.locus != nil {
		return *m.locus, true
	}
	return
}

// LocusIDs returns the "locus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocusID instead. It exists only for internal usage by the builders.
func (m *TranscriptMutation) LocusIDs() (ids []string) {
	if id := m.locus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocus resets all changes to the "locus" edge.
func (m *TranscriptMutation) ResetLocus() {
	m.locus = nil
	m.clearedlocus = false
}

// Where appends a list predicates to the TranscriptMutation builder.
func (m *TranscriptMutation) Where(ps ...predicate.Transcript) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TranscriptMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transcript).
func (m *TranscriptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TranscriptMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.seqname != nil {
		fields = append(fields, transcript.FieldSeqname)
	}
	if m.strand != nil {
		fields = append(fields, transcript.FieldStrand)
	}
	if m._type != nil {
		fields = append(fields, transcript.FieldType)
	}
	if m.start != nil {
		fields = append(fields, transcript.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, transcript.FieldEnd)
	}
	if m.exon != nil {
		fields = append(fields, transcript.FieldExon)
	}
	if m.five_prime_utr != nil {
		fields = append(fields, transcript.FieldFivePrimeUtr)
	}
	if m.three_prime_utr != nil {
		fields = append(fields, transcript.FieldThreePrimeUtr)
	}
	if m.cds != nil {
		fields = append(fields, transcript.FieldCds)
	}
	if m.genomic_sequence != nil {
		fields = append(fields, transcript.FieldGenomicSequence)
	}
	if m.exon_sequence != nil {
		fields = append(fields, transcript.FieldExonSequence)
	}
	if m.cds_sequence != nil {
		fields = append(fields, transcript.FieldCdsSequence)
	}
	if m.protein_sequence != nil {
		fields = append(fields, transcript.FieldProteinSequence)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TranscriptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transcript.FieldSeqname:
		return m.Seqname()
	case transcript.FieldStrand:
		return m.Strand()
	case transcript.FieldType:
		return m.GetType()
	case transcript.FieldStart:
		return m.Start()
	case transcript.FieldEnd:
		return m.End()
	case transcript.FieldExon:
		return m.Exon()
	case transcript.FieldFivePrimeUtr:
		return m.FivePrimeUtr()
	case transcript.FieldThreePrimeUtr:
		return m.ThreePrimeUtr()
	case transcript.FieldCds:
		return m.Cds()
	case transcript.FieldGenomicSequence:
		return m.GenomicSequence()
	case transcript.FieldExonSequence:
		return m.ExonSequence()
	case transcript.FieldCdsSequence:
		return m.CdsSequence()
	case transcript.FieldProteinSequence:
		return m.ProteinSequence()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TranscriptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transcript.FieldSeqname:
		return m.OldSeqname(ctx)
	case transcript.FieldStrand:
		return m.OldStrand(ctx)
	case transcript.FieldType:
		return m.OldType(ctx)
	case transcript.FieldStart:
		return m.OldStart(ctx)
	case transcript.FieldEnd:
		return m.OldEnd(ctx)
	case transcript.FieldExon:
		return m.OldExon(ctx)
	case transcript.FieldFivePrimeUtr:
		return m.OldFivePrimeUtr(ctx)
	case transcript.FieldThreePrimeUtr:
		return m.OldThreePrimeUtr(ctx)
	case transcript.FieldCds:
		return m.OldCds(ctx)
	case transcript.FieldGenomicSequence:
		return m.OldGenomicSequence(ctx)
	case transcript.FieldExonSequence:
		return m.OldExonSequence(ctx)
	case transcript.FieldCdsSequence:
		return m.OldCdsSequence(ctx)
	case transcript.FieldProteinSequence:
		return m.OldProteinSequence(ctx)
	}
	return nil, fmt.Errorf("unknown Transcript field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TranscriptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transcript.FieldSeqname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqname(v)
		return nil
	case transcript.FieldStrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrand(v)
		return nil
	case transcript.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transcript.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case transcript.FieldEnd:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case transcript.FieldExon:
		v, ok := value.([]gffio.GffRecord)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExon(v)
		return nil
	case transcript.FieldFivePrimeUtr:
		v, ok := value.([]gffio.GffRecord)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFivePrimeUtr(v)
		return nil
	case transcript.FieldThreePrimeUtr:
		v, ok := value.([]gffio.GffRecord)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreePrimeUtr(v)
		return nil
	case transcript.FieldCds:
		v, ok := value.([]gffio.GffRecord)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCds(v)
		return nil
	case transcript.FieldGenomicSequence:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenomicSequence(v)
		return nil
	case transcript.FieldExonSequence:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExonSequence(v)
		return nil
	case transcript.FieldCdsSequence:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCdsSequence(v)
		return nil
	case transcript.FieldProteinSequence:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProteinSequence(v)
		return nil
	}
	return fmt.Errorf("unknown Transcript field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TranscriptMutation) AddedFields() []string {
	var fields []string
	if m.addstart != nil {
		fields = append(fields, transcript.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, transcript.FieldEnd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TranscriptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transcript.FieldStart:
		return m.AddedStart()
	case transcript.FieldEnd:
		return m.AddedEnd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TranscriptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transcript.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case transcript.FieldEnd:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	}
	return fmt.Errorf("unknown Transcript numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TranscriptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TranscriptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TranscriptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Transcript nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TranscriptMutation) ResetField(name string) error {
	switch name {
	case transcript.FieldSeqname:
		m.ResetSeqname()
		return nil
	case transcript.FieldStrand:
		m.ResetStrand()
		return nil
	case transcript.FieldType:
		m.ResetType()
		return nil
	case transcript.FieldStart:
		m.ResetStart()
		return nil
	case transcript.FieldEnd:
		m.ResetEnd()
		return nil
	case transcript.FieldExon:
		m.ResetExon()
		return nil
	case transcript.FieldFivePrimeUtr:
		m.ResetFivePrimeUtr()
		return nil
	case transcript.FieldThreePrimeUtr:
		m.ResetThreePrimeUtr()
		return nil
	case transcript.FieldCds:
		m.ResetCds()
		return nil
	case transcript.FieldGenomicSequence:
		m.ResetGenomicSequence()
		return nil
	case transcript.FieldExonSequence:
		m.ResetExonSequence()
		return nil
	case transcript.FieldCdsSequence:
		m.ResetCdsSequence()
		return nil
	case transcript.FieldProteinSequence:
		m.ResetProteinSequence()
		return nil
	}
	return fmt.Errorf("unknown Transcript field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TranscriptMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.locus != nil {
		edges = append(edges, transcript.EdgeLocus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TranscriptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transcript.EdgeLocus:
		if id := m.locus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TranscriptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TranscriptMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TranscriptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlocus {
		edges = append(edges, transcript.EdgeLocus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TranscriptMutation) EdgeCleared(name string) bool {
	switch name {
	case transcript.EdgeLocus:
		return m.clearedlocus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TranscriptMutation) ClearEdge(name string) error {
	switch name {
	case transcript.EdgeLocus:
		m.ClearLocus()
		return nil
	}
	return fmt.Errorf("unknown Transcript unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TranscriptMutation) ResetEdge(name string) error {
	switch name {
	case transcript.EdgeLocus:
		m.ResetLocus()
		return nil
	}
	return fmt.Errorf("unknown Transcript edge %s", name)
}
