// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"genomedb/ent/cds"
	"genomedb/ent/exon"
	"genomedb/ent/fiveprimeutr"
	"genomedb/ent/gene"
	"genomedb/ent/genome"
	"genomedb/ent/predicate"
	"genomedb/ent/scaffold"
	"genomedb/ent/threeprimeutr"
	"genomedb/ent/transcript"
	"sync"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCds           = "Cds"
	TypeExon          = "Exon"
	TypeFivePrimeUtr  = "FivePrimeUtr"
	TypeGene          = "Gene"
	TypeGenome        = "Genome"
	TypeScaffold      = "Scaffold"
	TypeThreePrimeUtr = "ThreePrimeUtr"
	TypeTranscript    = "Transcript"
)

// CdsMutation represents an operation that mutates the Cds nodes in the graph.
type CdsMutation struct {
	config
	op                Op
	typ               string
	id                *int
	seqname           *string
	start             *int32
	addstart          *int32
	end               *int32
	addend            *int32
	frame             *int8
	addframe          *int8
	strand            *string
	clearedFields     map[string]struct{}
	transcript        *string
	clearedtranscript bool
	done              bool
	oldValue          func(context.Context) (*Cds, error)
	predicates        []predicate.Cds
}

var _ ent.Mutation = (*CdsMutation)(nil)

// cdsOption allows management of the mutation configuration using functional options.
type cdsOption func(*CdsMutation)

// newCdsMutation creates new mutation for the Cds entity.
func newCdsMutation(c config, op Op, opts ...cdsOption) *CdsMutation {
	m := &CdsMutation{
		config:        c,
		op:            op,
		typ:           TypeCds,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCdsID sets the ID field of the mutation.
func withCdsID(id int) cdsOption {
	return func(m *CdsMutation) {
		var (
			err   error
			once  sync.Once
			value *Cds
		)
		m.oldValue = func(ctx context.Context) (*Cds, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cds.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCds sets the old Cds of the mutation.
func withCds(node *Cds) cdsOption {
	return func(m *CdsMutation) {
		m.oldValue = func(context.Context) (*Cds, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CdsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CdsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CdsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CdsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cds.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeqname sets the "seqname" field.
func (m *CdsMutation) SetSeqname(s string) {
	m.seqname = &s
}

// Seqname returns the value of the "seqname" field in the mutation.
func (m *CdsMutation) Seqname() (r string, exists bool) {
	v := m.seqname
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqname returns the old "seqname" field's value of the Cds entity.
// If the Cds object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CdsMutation) OldSeqname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeqname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeqname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqname: %w", err)
	}
	return oldValue.Seqname, nil
}

// ResetSeqname resets all changes to the "seqname" field.
func (m *CdsMutation) ResetSeqname() {
	m.seqname = nil
}

// SetStart sets the "start" field.
func (m *CdsMutation) SetStart(i int32) {
	m.start = &i
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *CdsMutation) Start() (r int32, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the Cds entity.
// If the Cds object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CdsMutation) OldStart(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds i to the "start" field.
func (m *CdsMutation) AddStart(i int32) {
	if m.addstart != nil {
		*m.addstart += i
	} else {
		m.addstart = &i
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *CdsMutation) AddedStart() (r int32, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *CdsMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *CdsMutation) SetEnd(i int32) {
	m.end = &i
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *CdsMutation) End() (r int32, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the Cds entity.
// If the Cds object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CdsMutation) OldEnd(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds i to the "end" field.
func (m *CdsMutation) AddEnd(i int32) {
	if m.addend != nil {
		*m.addend += i
	} else {
		m.addend = &i
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *CdsMutation) AddedEnd() (r int32, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *CdsMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetFrame sets the "frame" field.
func (m *CdsMutation) SetFrame(i int8) {
	m.frame = &i
	m.addframe = nil
}

// Frame returns the value of the "frame" field in the mutation.
func (m *CdsMutation) Frame() (r int8, exists bool) {
	v := m.frame
	if v == nil {
		return
	}
	return *v, true
}

// OldFrame returns the old "frame" field's value of the Cds entity.
// If the Cds object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CdsMutation) OldFrame(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrame is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrame requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrame: %w", err)
	}
	return oldValue.Frame, nil
}

// AddFrame adds i to the "frame" field.
func (m *CdsMutation) AddFrame(i int8) {
	if m.addframe != nil {
		*m.addframe += i
	} else {
		m.addframe = &i
	}
}

// AddedFrame returns the value that was added to the "frame" field in this mutation.
func (m *CdsMutation) AddedFrame() (r int8, exists bool) {
	v := m.addframe
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrame resets all changes to the "frame" field.
func (m *CdsMutation) ResetFrame() {
	m.frame = nil
	m.addframe = nil
}

// SetStrand sets the "strand" field.
func (m *CdsMutation) SetStrand(s string) {
	m.strand = &s
}

// Strand returns the value of the "strand" field in the mutation.
func (m *CdsMutation) Strand() (r string, exists bool) {
	v := m.strand
	if v == nil {
		return
	}
	return *v, true
}

// OldStrand returns the old "strand" field's value of the Cds entity.
// If the Cds object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CdsMutation) OldStrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrand: %w", err)
	}
	return oldValue.Strand, nil
}

// ResetStrand resets all changes to the "strand" field.
func (m *CdsMutation) ResetStrand() {
	m.strand = nil
}

// SetTranscriptID sets the "transcript" edge to the Transcript entity by id.
func (m *CdsMutation) SetTranscriptID(id string) {
	m.transcript = &id
}

// ClearTranscript clears the "transcript" edge to the Transcript entity.
func (m *CdsMutation) ClearTranscript() {
	m.clearedtranscript = true
}

// TranscriptCleared reports if the "transcript" edge to the Transcript entity was cleared.
func (m *CdsMutation) TranscriptCleared() bool {
	return m.clearedtranscript
}

// TranscriptID returns the "transcript" edge ID in the mutation.
func (m *CdsMutation) TranscriptID() (id string, exists bool) {
	if m.transcript != nil {
		return *m.transcript, true
	}
	return
}

// TranscriptIDs returns the "transcript" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TranscriptID instead. It exists only for internal usage by the builders.
func (m *CdsMutation) TranscriptIDs() (ids []string) {
	if id := m.transcript; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTranscript resets all changes to the "transcript" edge.
func (m *CdsMutation) ResetTranscript() {
	m.transcript = nil
	m.clearedtranscript = false
}

// Where appends a list predicates to the CdsMutation builder.
func (m *CdsMutation) Where(ps ...predicate.Cds) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CdsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cds).
func (m *CdsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CdsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.seqname != nil {
		fields = append(fields, cds.FieldSeqname)
	}
	if m.start != nil {
		fields = append(fields, cds.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, cds.FieldEnd)
	}
	if m.frame != nil {
		fields = append(fields, cds.FieldFrame)
	}
	if m.strand != nil {
		fields = append(fields, cds.FieldStrand)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CdsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cds.FieldSeqname:
		return m.Seqname()
	case cds.FieldStart:
		return m.Start()
	case cds.FieldEnd:
		return m.End()
	case cds.FieldFrame:
		return m.Frame()
	case cds.FieldStrand:
		return m.Strand()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CdsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cds.FieldSeqname:
		return m.OldSeqname(ctx)
	case cds.FieldStart:
		return m.OldStart(ctx)
	case cds.FieldEnd:
		return m.OldEnd(ctx)
	case cds.FieldFrame:
		return m.OldFrame(ctx)
	case cds.FieldStrand:
		return m.OldStrand(ctx)
	}
	return nil, fmt.Errorf("unknown Cds field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CdsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cds.FieldSeqname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqname(v)
		return nil
	case cds.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case cds.FieldEnd:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case cds.FieldFrame:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrame(v)
		return nil
	case cds.FieldStrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrand(v)
		return nil
	}
	return fmt.Errorf("unknown Cds field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CdsMutation) AddedFields() []string {
	var fields []string
	if m.addstart != nil {
		fields = append(fields, cds.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, cds.FieldEnd)
	}
	if m.addframe != nil {
		fields = append(fields, cds.FieldFrame)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CdsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cds.FieldStart:
		return m.AddedStart()
	case cds.FieldEnd:
		return m.AddedEnd()
	case cds.FieldFrame:
		return m.AddedFrame()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CdsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cds.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case cds.FieldEnd:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	case cds.FieldFrame:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrame(v)
		return nil
	}
	return fmt.Errorf("unknown Cds numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CdsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CdsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CdsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cds nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CdsMutation) ResetField(name string) error {
	switch name {
	case cds.FieldSeqname:
		m.ResetSeqname()
		return nil
	case cds.FieldStart:
		m.ResetStart()
		return nil
	case cds.FieldEnd:
		m.ResetEnd()
		return nil
	case cds.FieldFrame:
		m.ResetFrame()
		return nil
	case cds.FieldStrand:
		m.ResetStrand()
		return nil
	}
	return fmt.Errorf("unknown Cds field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CdsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transcript != nil {
		edges = append(edges, cds.EdgeTranscript)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CdsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cds.EdgeTranscript:
		if id := m.transcript; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CdsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CdsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CdsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtranscript {
		edges = append(edges, cds.EdgeTranscript)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CdsMutation) EdgeCleared(name string) bool {
	switch name {
	case cds.EdgeTranscript:
		return m.clearedtranscript
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CdsMutation) ClearEdge(name string) error {
	switch name {
	case cds.EdgeTranscript:
		m.ClearTranscript()
		return nil
	}
	return fmt.Errorf("unknown Cds unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CdsMutation) ResetEdge(name string) error {
	switch name {
	case cds.EdgeTranscript:
		m.ResetTranscript()
		return nil
	}
	return fmt.Errorf("unknown Cds edge %s", name)
}

// ExonMutation represents an operation that mutates the Exon nodes in the graph.
type ExonMutation struct {
	config
	op                Op
	typ               string
	id                *int
	seqname           *string
	start             *int32
	addstart          *int32
	end               *int32
	addend            *int32
	strand            *string
	clearedFields     map[string]struct{}
	transcript        *string
	clearedtranscript bool
	done              bool
	oldValue          func(context.Context) (*Exon, error)
	predicates        []predicate.Exon
}

var _ ent.Mutation = (*ExonMutation)(nil)

// exonOption allows management of the mutation configuration using functional options.
type exonOption func(*ExonMutation)

// newExonMutation creates new mutation for the Exon entity.
func newExonMutation(c config, op Op, opts ...exonOption) *ExonMutation {
	m := &ExonMutation{
		config:        c,
		op:            op,
		typ:           TypeExon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExonID sets the ID field of the mutation.
func withExonID(id int) exonOption {
	return func(m *ExonMutation) {
		var (
			err   error
			once  sync.Once
			value *Exon
		)
		m.oldValue = func(ctx context.Context) (*Exon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExon sets the old Exon of the mutation.
func withExon(node *Exon) exonOption {
	return func(m *ExonMutation) {
		m.oldValue = func(context.Context) (*Exon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExonMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeqname sets the "seqname" field.
func (m *ExonMutation) SetSeqname(s string) {
	m.seqname = &s
}

// Seqname returns the value of the "seqname" field in the mutation.
func (m *ExonMutation) Seqname() (r string, exists bool) {
	v := m.seqname
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqname returns the old "seqname" field's value of the Exon entity.
// If the Exon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExonMutation) OldSeqname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeqname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeqname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqname: %w", err)
	}
	return oldValue.Seqname, nil
}

// ResetSeqname resets all changes to the "seqname" field.
func (m *ExonMutation) ResetSeqname() {
	m.seqname = nil
}

// SetStart sets the "start" field.
func (m *ExonMutation) SetStart(i int32) {
	m.start = &i
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *ExonMutation) Start() (r int32, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the Exon entity.
// If the Exon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExonMutation) OldStart(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds i to the "start" field.
func (m *ExonMutation) AddStart(i int32) {
	if m.addstart != nil {
		*m.addstart += i
	} else {
		m.addstart = &i
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *ExonMutation) AddedStart() (r int32, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *ExonMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *ExonMutation) SetEnd(i int32) {
	m.end = &i
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *ExonMutation) End() (r int32, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the Exon entity.
// If the Exon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExonMutation) OldEnd(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds i to the "end" field.
func (m *ExonMutation) AddEnd(i int32) {
	if m.addend != nil {
		*m.addend += i
	} else {
		m.addend = &i
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *ExonMutation) AddedEnd() (r int32, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *ExonMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetStrand sets the "strand" field.
func (m *ExonMutation) SetStrand(s string) {
	m.strand = &s
}

// Strand returns the value of the "strand" field in the mutation.
func (m *ExonMutation) Strand() (r string, exists bool) {
	v := m.strand
	if v == nil {
		return
	}
	return *v, true
}

// OldStrand returns the old "strand" field's value of the Exon entity.
// If the Exon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExonMutation) OldStrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrand: %w", err)
	}
	return oldValue.Strand, nil
}

// ResetStrand resets all changes to the "strand" field.
func (m *ExonMutation) ResetStrand() {
	m.strand = nil
}

// SetTranscriptID sets the "transcript" edge to the Transcript entity by id.
func (m *ExonMutation) SetTranscriptID(id string) {
	m.transcript = &id
}

// ClearTranscript clears the "transcript" edge to the Transcript entity.
func (m *ExonMutation) ClearTranscript() {
	m.clearedtranscript = true
}

// TranscriptCleared reports if the "transcript" edge to the Transcript entity was cleared.
func (m *ExonMutation) TranscriptCleared() bool {
	return m.clearedtranscript
}

// TranscriptID returns the "transcript" edge ID in the mutation.
func (m *ExonMutation) TranscriptID() (id string, exists bool) {
	if m.transcript != nil {
		return *m.transcript, true
	}
	return
}

// TranscriptIDs returns the "transcript" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TranscriptID instead. It exists only for internal usage by the builders.
func (m *ExonMutation) TranscriptIDs() (ids []string) {
	if id := m.transcript; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTranscript resets all changes to the "transcript" edge.
func (m *ExonMutation) ResetTranscript() {
	m.transcript = nil
	m.clearedtranscript = false
}

// Where appends a list predicates to the ExonMutation builder.
func (m *ExonMutation) Where(ps ...predicate.Exon) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ExonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Exon).
func (m *ExonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExonMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.seqname != nil {
		fields = append(fields, exon.FieldSeqname)
	}
	if m.start != nil {
		fields = append(fields, exon.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, exon.FieldEnd)
	}
	if m.strand != nil {
		fields = append(fields, exon.FieldStrand)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exon.FieldSeqname:
		return m.Seqname()
	case exon.FieldStart:
		return m.Start()
	case exon.FieldEnd:
		return m.End()
	case exon.FieldStrand:
		return m.Strand()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exon.FieldSeqname:
		return m.OldSeqname(ctx)
	case exon.FieldStart:
		return m.OldStart(ctx)
	case exon.FieldEnd:
		return m.OldEnd(ctx)
	case exon.FieldStrand:
		return m.OldStrand(ctx)
	}
	return nil, fmt.Errorf("unknown Exon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exon.FieldSeqname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqname(v)
		return nil
	case exon.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case exon.FieldEnd:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case exon.FieldStrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrand(v)
		return nil
	}
	return fmt.Errorf("unknown Exon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExonMutation) AddedFields() []string {
	var fields []string
	if m.addstart != nil {
		fields = append(fields, exon.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, exon.FieldEnd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exon.FieldStart:
		return m.AddedStart()
	case exon.FieldEnd:
		return m.AddedEnd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exon.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case exon.FieldEnd:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	}
	return fmt.Errorf("unknown Exon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Exon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExonMutation) ResetField(name string) error {
	switch name {
	case exon.FieldSeqname:
		m.ResetSeqname()
		return nil
	case exon.FieldStart:
		m.ResetStart()
		return nil
	case exon.FieldEnd:
		m.ResetEnd()
		return nil
	case exon.FieldStrand:
		m.ResetStrand()
		return nil
	}
	return fmt.Errorf("unknown Exon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExonMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transcript != nil {
		edges = append(edges, exon.EdgeTranscript)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exon.EdgeTranscript:
		if id := m.transcript; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExonMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtranscript {
		edges = append(edges, exon.EdgeTranscript)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExonMutation) EdgeCleared(name string) bool {
	switch name {
	case exon.EdgeTranscript:
		return m.clearedtranscript
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExonMutation) ClearEdge(name string) error {
	switch name {
	case exon.EdgeTranscript:
		m.ClearTranscript()
		return nil
	}
	return fmt.Errorf("unknown Exon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExonMutation) ResetEdge(name string) error {
	switch name {
	case exon.EdgeTranscript:
		m.ResetTranscript()
		return nil
	}
	return fmt.Errorf("unknown Exon edge %s", name)
}

// FivePrimeUtrMutation represents an operation that mutates the FivePrimeUtr nodes in the graph.
type FivePrimeUtrMutation struct {
	config
	op                Op
	typ               string
	id                *int
	seqname           *string
	start             *int32
	addstart          *int32
	end               *int32
	addend            *int32
	strand            *string
	clearedFields     map[string]struct{}
	transcript        *string
	clearedtranscript bool
	done              bool
	oldValue          func(context.Context) (*FivePrimeUtr, error)
	predicates        []predicate.FivePrimeUtr
}

var _ ent.Mutation = (*FivePrimeUtrMutation)(nil)

// fiveprimeutrOption allows management of the mutation configuration using functional options.
type fiveprimeutrOption func(*FivePrimeUtrMutation)

// newFivePrimeUtrMutation creates new mutation for the FivePrimeUtr entity.
func newFivePrimeUtrMutation(c config, op Op, opts ...fiveprimeutrOption) *FivePrimeUtrMutation {
	m := &FivePrimeUtrMutation{
		config:        c,
		op:            op,
		typ:           TypeFivePrimeUtr,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFivePrimeUtrID sets the ID field of the mutation.
func withFivePrimeUtrID(id int) fiveprimeutrOption {
	return func(m *FivePrimeUtrMutation) {
		var (
			err   error
			once  sync.Once
			value *FivePrimeUtr
		)
		m.oldValue = func(ctx context.Context) (*FivePrimeUtr, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FivePrimeUtr.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFivePrimeUtr sets the old FivePrimeUtr of the mutation.
func withFivePrimeUtr(node *FivePrimeUtr) fiveprimeutrOption {
	return func(m *FivePrimeUtrMutation) {
		m.oldValue = func(context.Context) (*FivePrimeUtr, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FivePrimeUtrMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FivePrimeUtrMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FivePrimeUtrMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FivePrimeUtrMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FivePrimeUtr.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeqname sets the "seqname" field.
func (m *FivePrimeUtrMutation) SetSeqname(s string) {
	m.seqname = &s
}

// Seqname returns the value of the "seqname" field in the mutation.
func (m *FivePrimeUtrMutation) Seqname() (r string, exists bool) {
	v := m.seqname
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqname returns the old "seqname" field's value of the FivePrimeUtr entity.
// If the FivePrimeUtr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FivePrimeUtrMutation) OldSeqname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeqname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeqname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqname: %w", err)
	}
	return oldValue.Seqname, nil
}

// ResetSeqname resets all changes to the "seqname" field.
func (m *FivePrimeUtrMutation) ResetSeqname() {
	m.seqname = nil
}

// SetStart sets the "start" field.
func (m *FivePrimeUtrMutation) SetStart(i int32) {
	m.start = &i
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *FivePrimeUtrMutation) Start() (r int32, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the FivePrimeUtr entity.
// If the FivePrimeUtr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FivePrimeUtrMutation) OldStart(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds i to the "start" field.
func (m *FivePrimeUtrMutation) AddStart(i int32) {
	if m.addstart != nil {
		*m.addstart += i
	} else {
		m.addstart = &i
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *FivePrimeUtrMutation) AddedStart() (r int32, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *FivePrimeUtrMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *FivePrimeUtrMutation) SetEnd(i int32) {
	m.end = &i
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *FivePrimeUtrMutation) End() (r int32, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the FivePrimeUtr entity.
// If the FivePrimeUtr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FivePrimeUtrMutation) OldEnd(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds i to the "end" field.
func (m *FivePrimeUtrMutation) AddEnd(i int32) {
	if m.addend != nil {
		*m.addend += i
	} else {
		m.addend = &i
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *FivePrimeUtrMutation) AddedEnd() (r int32, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *FivePrimeUtrMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetStrand sets the "strand" field.
func (m *FivePrimeUtrMutation) SetStrand(s string) {
	m.strand = &s
}

// Strand returns the value of the "strand" field in the mutation.
func (m *FivePrimeUtrMutation) Strand() (r string, exists bool) {
	v := m.strand
	if v == nil {
		return
	}
	return *v, true
}

// OldStrand returns the old "strand" field's value of the FivePrimeUtr entity.
// If the FivePrimeUtr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FivePrimeUtrMutation) OldStrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrand: %w", err)
	}
	return oldValue.Strand, nil
}

// ResetStrand resets all changes to the "strand" field.
func (m *FivePrimeUtrMutation) ResetStrand() {
	m.strand = nil
}

// SetTranscriptID sets the "transcript" edge to the Transcript entity by id.
func (m *FivePrimeUtrMutation) SetTranscriptID(id string) {
	m.transcript = &id
}

// ClearTranscript clears the "transcript" edge to the Transcript entity.
func (m *FivePrimeUtrMutation) ClearTranscript() {
	m.clearedtranscript = true
}

// TranscriptCleared reports if the "transcript" edge to the Transcript entity was cleared.
func (m *FivePrimeUtrMutation) TranscriptCleared() bool {
	return m.clearedtranscript
}

// TranscriptID returns the "transcript" edge ID in the mutation.
func (m *FivePrimeUtrMutation) TranscriptID() (id string, exists bool) {
	if m.transcript != nil {
		return *m.transcript, true
	}
	return
}

// TranscriptIDs returns the "transcript" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TranscriptID instead. It exists only for internal usage by the builders.
func (m *FivePrimeUtrMutation) TranscriptIDs() (ids []string) {
	if id := m.transcript; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTranscript resets all changes to the "transcript" edge.
func (m *FivePrimeUtrMutation) ResetTranscript() {
	m.transcript = nil
	m.clearedtranscript = false
}

// Where appends a list predicates to the FivePrimeUtrMutation builder.
func (m *FivePrimeUtrMutation) Where(ps ...predicate.FivePrimeUtr) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FivePrimeUtrMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FivePrimeUtr).
func (m *FivePrimeUtrMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FivePrimeUtrMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.seqname != nil {
		fields = append(fields, fiveprimeutr.FieldSeqname)
	}
	if m.start != nil {
		fields = append(fields, fiveprimeutr.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, fiveprimeutr.FieldEnd)
	}
	if m.strand != nil {
		fields = append(fields, fiveprimeutr.FieldStrand)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FivePrimeUtrMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fiveprimeutr.FieldSeqname:
		return m.Seqname()
	case fiveprimeutr.FieldStart:
		return m.Start()
	case fiveprimeutr.FieldEnd:
		return m.End()
	case fiveprimeutr.FieldStrand:
		return m.Strand()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FivePrimeUtrMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fiveprimeutr.FieldSeqname:
		return m.OldSeqname(ctx)
	case fiveprimeutr.FieldStart:
		return m.OldStart(ctx)
	case fiveprimeutr.FieldEnd:
		return m.OldEnd(ctx)
	case fiveprimeutr.FieldStrand:
		return m.OldStrand(ctx)
	}
	return nil, fmt.Errorf("unknown FivePrimeUtr field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FivePrimeUtrMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fiveprimeutr.FieldSeqname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqname(v)
		return nil
	case fiveprimeutr.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case fiveprimeutr.FieldEnd:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case fiveprimeutr.FieldStrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrand(v)
		return nil
	}
	return fmt.Errorf("unknown FivePrimeUtr field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FivePrimeUtrMutation) AddedFields() []string {
	var fields []string
	if m.addstart != nil {
		fields = append(fields, fiveprimeutr.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, fiveprimeutr.FieldEnd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FivePrimeUtrMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fiveprimeutr.FieldStart:
		return m.AddedStart()
	case fiveprimeutr.FieldEnd:
		return m.AddedEnd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FivePrimeUtrMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fiveprimeutr.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case fiveprimeutr.FieldEnd:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	}
	return fmt.Errorf("unknown FivePrimeUtr numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FivePrimeUtrMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FivePrimeUtrMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FivePrimeUtrMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FivePrimeUtr nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FivePrimeUtrMutation) ResetField(name string) error {
	switch name {
	case fiveprimeutr.FieldSeqname:
		m.ResetSeqname()
		return nil
	case fiveprimeutr.FieldStart:
		m.ResetStart()
		return nil
	case fiveprimeutr.FieldEnd:
		m.ResetEnd()
		return nil
	case fiveprimeutr.FieldStrand:
		m.ResetStrand()
		return nil
	}
	return fmt.Errorf("unknown FivePrimeUtr field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FivePrimeUtrMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transcript != nil {
		edges = append(edges, fiveprimeutr.EdgeTranscript)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FivePrimeUtrMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fiveprimeutr.EdgeTranscript:
		if id := m.transcript; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FivePrimeUtrMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FivePrimeUtrMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FivePrimeUtrMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtranscript {
		edges = append(edges, fiveprimeutr.EdgeTranscript)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FivePrimeUtrMutation) EdgeCleared(name string) bool {
	switch name {
	case fiveprimeutr.EdgeTranscript:
		return m.clearedtranscript
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FivePrimeUtrMutation) ClearEdge(name string) error {
	switch name {
	case fiveprimeutr.EdgeTranscript:
		m.ClearTranscript()
		return nil
	}
	return fmt.Errorf("unknown FivePrimeUtr unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FivePrimeUtrMutation) ResetEdge(name string) error {
	switch name {
	case fiveprimeutr.EdgeTranscript:
		m.ResetTranscript()
		return nil
	}
	return fmt.Errorf("unknown FivePrimeUtr edge %s", name)
}

// GeneMutation represents an operation that mutates the Gene nodes in the graph.
type GeneMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	clearedFields      map[string]struct{}
	transcripts        map[string]struct{}
	removedtranscripts map[string]struct{}
	clearedtranscripts bool
	genome             *string
	clearedgenome      bool
	done               bool
	oldValue           func(context.Context) (*Gene, error)
	predicates         []predicate.Gene
}

var _ ent.Mutation = (*GeneMutation)(nil)

// geneOption allows management of the mutation configuration using functional options.
type geneOption func(*GeneMutation)

// newGeneMutation creates new mutation for the Gene entity.
func newGeneMutation(c config, op Op, opts ...geneOption) *GeneMutation {
	m := &GeneMutation{
		config:        c,
		op:            op,
		typ:           TypeGene,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGeneID sets the ID field of the mutation.
func withGeneID(id string) geneOption {
	return func(m *GeneMutation) {
		var (
			err   error
			once  sync.Once
			value *Gene
		)
		m.oldValue = func(ctx context.Context) (*Gene, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gene.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGene sets the old Gene of the mutation.
func withGene(node *Gene) geneOption {
	return func(m *GeneMutation) {
		m.oldValue = func(context.Context) (*Gene, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GeneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GeneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Gene entities.
func (m *GeneMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GeneMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GeneMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Gene.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddTranscriptIDs adds the "transcripts" edge to the Transcript entity by ids.
func (m *GeneMutation) AddTranscriptIDs(ids ...string) {
	if m.transcripts == nil {
		m.transcripts = make(map[string]struct{})
	}
	for i := range ids {
		m.transcripts[ids[i]] = struct{}{}
	}
}

// ClearTranscripts clears the "transcripts" edge to the Transcript entity.
func (m *GeneMutation) ClearTranscripts() {
	m.clearedtranscripts = true
}

// TranscriptsCleared reports if the "transcripts" edge to the Transcript entity was cleared.
func (m *GeneMutation) TranscriptsCleared() bool {
	return m.clearedtranscripts
}

// RemoveTranscriptIDs removes the "transcripts" edge to the Transcript entity by IDs.
func (m *GeneMutation) RemoveTranscriptIDs(ids ...string) {
	if m.removedtranscripts == nil {
		m.removedtranscripts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transcripts, ids[i])
		m.removedtranscripts[ids[i]] = struct{}{}
	}
}

// RemovedTranscripts returns the removed IDs of the "transcripts" edge to the Transcript entity.
func (m *GeneMutation) RemovedTranscriptsIDs() (ids []string) {
	for id := range m.removedtranscripts {
		ids = append(ids, id)
	}
	return
}

// TranscriptsIDs returns the "transcripts" edge IDs in the mutation.
func (m *GeneMutation) TranscriptsIDs() (ids []string) {
	for id := range m.transcripts {
		ids = append(ids, id)
	}
	return
}

// ResetTranscripts resets all changes to the "transcripts" edge.
func (m *GeneMutation) ResetTranscripts() {
	m.transcripts = nil
	m.clearedtranscripts = false
	m.removedtranscripts = nil
}

// SetGenomeID sets the "genome" edge to the Genome entity by id.
func (m *GeneMutation) SetGenomeID(id string) {
	m.genome = &id
}

// ClearGenome clears the "genome" edge to the Genome entity.
func (m *GeneMutation) ClearGenome() {
	m.clearedgenome = true
}

// GenomeCleared reports if the "genome" edge to the Genome entity was cleared.
func (m *GeneMutation) GenomeCleared() bool {
	return m.clearedgenome
}

// GenomeID returns the "genome" edge ID in the mutation.
func (m *GeneMutation) GenomeID() (id string, exists bool) {
	if m.genome != nil {
		return *m.genome, true
	}
	return
}

// GenomeIDs returns the "genome" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenomeID instead. It exists only for internal usage by the builders.
func (m *GeneMutation) GenomeIDs() (ids []string) {
	if id := m.genome; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenome resets all changes to the "genome" edge.
func (m *GeneMutation) ResetGenome() {
	m.genome = nil
	m.clearedgenome = false
}

// Where appends a list predicates to the GeneMutation builder.
func (m *GeneMutation) Where(ps ...predicate.Gene) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GeneMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Gene).
func (m *GeneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GeneMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GeneMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GeneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Gene field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeneMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Gene field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GeneMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GeneMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeneMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Gene numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GeneMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GeneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GeneMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Gene nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GeneMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Gene field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GeneMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.transcripts != nil {
		edges = append(edges, gene.EdgeTranscripts)
	}
	if m.genome != nil {
		edges = append(edges, gene.EdgeGenome)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GeneMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gene.EdgeTranscripts:
		ids := make([]ent.Value, 0, len(m.transcripts))
		for id := range m.transcripts {
			ids = append(ids, id)
		}
		return ids
	case gene.EdgeGenome:
		if id := m.genome; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GeneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtranscripts != nil {
		edges = append(edges, gene.EdgeTranscripts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GeneMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gene.EdgeTranscripts:
		ids := make([]ent.Value, 0, len(m.removedtranscripts))
		for id := range m.removedtranscripts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GeneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtranscripts {
		edges = append(edges, gene.EdgeTranscripts)
	}
	if m.clearedgenome {
		edges = append(edges, gene.EdgeGenome)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GeneMutation) EdgeCleared(name string) bool {
	switch name {
	case gene.EdgeTranscripts:
		return m.clearedtranscripts
	case gene.EdgeGenome:
		return m.clearedgenome
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GeneMutation) ClearEdge(name string) error {
	switch name {
	case gene.EdgeGenome:
		m.ClearGenome()
		return nil
	}
	return fmt.Errorf("unknown Gene unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GeneMutation) ResetEdge(name string) error {
	switch name {
	case gene.EdgeTranscripts:
		m.ResetTranscripts()
		return nil
	case gene.EdgeGenome:
		m.ResetGenome()
		return nil
	}
	return fmt.Errorf("unknown Gene edge %s", name)
}

// GenomeMutation represents an operation that mutates the Genome nodes in the graph.
type GenomeMutation struct {
	config
	op               Op
	typ              string
	id               *string
	codon_table      *int32
	addcodon_table   *int32
	clearedFields    map[string]struct{}
	genes            map[string]struct{}
	removedgenes     map[string]struct{}
	clearedgenes     bool
	scaffolds        map[int]struct{}
	removedscaffolds map[int]struct{}
	clearedscaffolds bool
	done             bool
	oldValue         func(context.Context) (*Genome, error)
	predicates       []predicate.Genome
}

var _ ent.Mutation = (*GenomeMutation)(nil)

// genomeOption allows management of the mutation configuration using functional options.
type genomeOption func(*GenomeMutation)

// newGenomeMutation creates new mutation for the Genome entity.
func newGenomeMutation(c config, op Op, opts ...genomeOption) *GenomeMutation {
	m := &GenomeMutation{
		config:        c,
		op:            op,
		typ:           TypeGenome,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenomeID sets the ID field of the mutation.
func withGenomeID(id string) genomeOption {
	return func(m *GenomeMutation) {
		var (
			err   error
			once  sync.Once
			value *Genome
		)
		m.oldValue = func(ctx context.Context) (*Genome, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Genome.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGenome sets the old Genome of the mutation.
func withGenome(node *Genome) genomeOption {
	return func(m *GenomeMutation) {
		m.oldValue = func(context.Context) (*Genome, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenomeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenomeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Genome entities.
func (m *GenomeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GenomeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GenomeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Genome.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCodonTable sets the "codon_table" field.
func (m *GenomeMutation) SetCodonTable(i int32) {
	m.codon_table = &i
	m.addcodon_table = nil
}

// CodonTable returns the value of the "codon_table" field in the mutation.
func (m *GenomeMutation) CodonTable() (r int32, exists bool) {
	v := m.codon_table
	if v == nil {
		return
	}
	return *v, true
}

// OldCodonTable returns the old "codon_table" field's value of the Genome entity.
// If the Genome object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenomeMutation) OldCodonTable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodonTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodonTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodonTable: %w", err)
	}
	return oldValue.CodonTable, nil
}

// AddCodonTable adds i to the "codon_table" field.
func (m *GenomeMutation) AddCodonTable(i int32) {
	if m.addcodon_table != nil {
		*m.addcodon_table += i
	} else {
		m.addcodon_table = &i
	}
}

// AddedCodonTable returns the value that was added to the "codon_table" field in this mutation.
func (m *GenomeMutation) AddedCodonTable() (r int32, exists bool) {
	v := m.addcodon_table
	if v == nil {
		return
	}
	return *v, true
}

// ResetCodonTable resets all changes to the "codon_table" field.
func (m *GenomeMutation) ResetCodonTable() {
	m.codon_table = nil
	m.addcodon_table = nil
}

// AddGeneIDs adds the "genes" edge to the Gene entity by ids.
func (m *GenomeMutation) AddGeneIDs(ids ...string) {
	if m.genes == nil {
		m.genes = make(map[string]struct{})
	}
	for i := range ids {
		m.genes[ids[i]] = struct{}{}
	}
}

// ClearGenes clears the "genes" edge to the Gene entity.
func (m *GenomeMutation) ClearGenes() {
	m.clearedgenes = true
}

// GenesCleared reports if the "genes" edge to the Gene entity was cleared.
func (m *GenomeMutation) GenesCleared() bool {
	return m.clearedgenes
}

// RemoveGeneIDs removes the "genes" edge to the Gene entity by IDs.
func (m *GenomeMutation) RemoveGeneIDs(ids ...string) {
	if m.removedgenes == nil {
		m.removedgenes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.genes, ids[i])
		m.removedgenes[ids[i]] = struct{}{}
	}
}

// RemovedGenes returns the removed IDs of the "genes" edge to the Gene entity.
func (m *GenomeMutation) RemovedGenesIDs() (ids []string) {
	for id := range m.removedgenes {
		ids = append(ids, id)
	}
	return
}

// GenesIDs returns the "genes" edge IDs in the mutation.
func (m *GenomeMutation) GenesIDs() (ids []string) {
	for id := range m.genes {
		ids = append(ids, id)
	}
	return
}

// ResetGenes resets all changes to the "genes" edge.
func (m *GenomeMutation) ResetGenes() {
	m.genes = nil
	m.clearedgenes = false
	m.removedgenes = nil
}

// AddScaffoldIDs adds the "scaffolds" edge to the Scaffold entity by ids.
func (m *GenomeMutation) AddScaffoldIDs(ids ...int) {
	if m.scaffolds == nil {
		m.scaffolds = make(map[int]struct{})
	}
	for i := range ids {
		m.scaffolds[ids[i]] = struct{}{}
	}
}

// ClearScaffolds clears the "scaffolds" edge to the Scaffold entity.
func (m *GenomeMutation) ClearScaffolds() {
	m.clearedscaffolds = true
}

// ScaffoldsCleared reports if the "scaffolds" edge to the Scaffold entity was cleared.
func (m *GenomeMutation) ScaffoldsCleared() bool {
	return m.clearedscaffolds
}

// RemoveScaffoldIDs removes the "scaffolds" edge to the Scaffold entity by IDs.
func (m *GenomeMutation) RemoveScaffoldIDs(ids ...int) {
	if m.removedscaffolds == nil {
		m.removedscaffolds = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scaffolds, ids[i])
		m.removedscaffolds[ids[i]] = struct{}{}
	}
}

// RemovedScaffolds returns the removed IDs of the "scaffolds" edge to the Scaffold entity.
func (m *GenomeMutation) RemovedScaffoldsIDs() (ids []int) {
	for id := range m.removedscaffolds {
		ids = append(ids, id)
	}
	return
}

// ScaffoldsIDs returns the "scaffolds" edge IDs in the mutation.
func (m *GenomeMutation) ScaffoldsIDs() (ids []int) {
	for id := range m.scaffolds {
		ids = append(ids, id)
	}
	return
}

// ResetScaffolds resets all changes to the "scaffolds" edge.
func (m *GenomeMutation) ResetScaffolds() {
	m.scaffolds = nil
	m.clearedscaffolds = false
	m.removedscaffolds = nil
}

// Where appends a list predicates to the GenomeMutation builder.
func (m *GenomeMutation) Where(ps ...predicate.Genome) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GenomeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Genome).
func (m *GenomeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenomeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.codon_table != nil {
		fields = append(fields, genome.FieldCodonTable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenomeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case genome.FieldCodonTable:
		return m.CodonTable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenomeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case genome.FieldCodonTable:
		return m.OldCodonTable(ctx)
	}
	return nil, fmt.Errorf("unknown Genome field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenomeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case genome.FieldCodonTable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodonTable(v)
		return nil
	}
	return fmt.Errorf("unknown Genome field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenomeMutation) AddedFields() []string {
	var fields []string
	if m.addcodon_table != nil {
		fields = append(fields, genome.FieldCodonTable)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenomeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case genome.FieldCodonTable:
		return m.AddedCodonTable()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenomeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case genome.FieldCodonTable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCodonTable(v)
		return nil
	}
	return fmt.Errorf("unknown Genome numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenomeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenomeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenomeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Genome nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenomeMutation) ResetField(name string) error {
	switch name {
	case genome.FieldCodonTable:
		m.ResetCodonTable()
		return nil
	}
	return fmt.Errorf("unknown Genome field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenomeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.genes != nil {
		edges = append(edges, genome.EdgeGenes)
	}
	if m.scaffolds != nil {
		edges = append(edges, genome.EdgeScaffolds)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenomeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case genome.EdgeGenes:
		ids := make([]ent.Value, 0, len(m.genes))
		for id := range m.genes {
			ids = append(ids, id)
		}
		return ids
	case genome.EdgeScaffolds:
		ids := make([]ent.Value, 0, len(m.scaffolds))
		for id := range m.scaffolds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenomeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedgenes != nil {
		edges = append(edges, genome.EdgeGenes)
	}
	if m.removedscaffolds != nil {
		edges = append(edges, genome.EdgeScaffolds)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenomeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case genome.EdgeGenes:
		ids := make([]ent.Value, 0, len(m.removedgenes))
		for id := range m.removedgenes {
			ids = append(ids, id)
		}
		return ids
	case genome.EdgeScaffolds:
		ids := make([]ent.Value, 0, len(m.removedscaffolds))
		for id := range m.removedscaffolds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenomeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgenes {
		edges = append(edges, genome.EdgeGenes)
	}
	if m.clearedscaffolds {
		edges = append(edges, genome.EdgeScaffolds)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenomeMutation) EdgeCleared(name string) bool {
	switch name {
	case genome.EdgeGenes:
		return m.clearedgenes
	case genome.EdgeScaffolds:
		return m.clearedscaffolds
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenomeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Genome unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenomeMutation) ResetEdge(name string) error {
	switch name {
	case genome.EdgeGenes:
		m.ResetGenes()
		return nil
	case genome.EdgeScaffolds:
		m.ResetScaffolds()
		return nil
	}
	return fmt.Errorf("unknown Genome edge %s", name)
}

// ScaffoldMutation represents an operation that mutates the Scaffold nodes in the graph.
type ScaffoldMutation struct {
	config
	op            Op
	typ           string
	id            *int
	seqname       *string
	seq           *string
	clearedFields map[string]struct{}
	genome        *string
	clearedgenome bool
	done          bool
	oldValue      func(context.Context) (*Scaffold, error)
	predicates    []predicate.Scaffold
}

var _ ent.Mutation = (*ScaffoldMutation)(nil)

// scaffoldOption allows management of the mutation configuration using functional options.
type scaffoldOption func(*ScaffoldMutation)

// newScaffoldMutation creates new mutation for the Scaffold entity.
func newScaffoldMutation(c config, op Op, opts ...scaffoldOption) *ScaffoldMutation {
	m := &ScaffoldMutation{
		config:        c,
		op:            op,
		typ:           TypeScaffold,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScaffoldID sets the ID field of the mutation.
func withScaffoldID(id int) scaffoldOption {
	return func(m *ScaffoldMutation) {
		var (
			err   error
			once  sync.Once
			value *Scaffold
		)
		m.oldValue = func(ctx context.Context) (*Scaffold, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scaffold.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScaffold sets the old Scaffold of the mutation.
func withScaffold(node *Scaffold) scaffoldOption {
	return func(m *ScaffoldMutation) {
		m.oldValue = func(context.Context) (*Scaffold, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScaffoldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScaffoldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScaffoldMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScaffoldMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Scaffold.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeqname sets the "seqname" field.
func (m *ScaffoldMutation) SetSeqname(s string) {
	m.seqname = &s
}

// Seqname returns the value of the "seqname" field in the mutation.
func (m *ScaffoldMutation) Seqname() (r string, exists bool) {
	v := m.seqname
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqname returns the old "seqname" field's value of the Scaffold entity.
// If the Scaffold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScaffoldMutation) OldSeqname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeqname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeqname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqname: %w", err)
	}
	return oldValue.Seqname, nil
}

// ResetSeqname resets all changes to the "seqname" field.
func (m *ScaffoldMutation) ResetSeqname() {
	m.seqname = nil
}

// SetSeq sets the "seq" field.
func (m *ScaffoldMutation) SetSeq(s string) {
	m.seq = &s
}

// Seq returns the value of the "seq" field in the mutation.
func (m *ScaffoldMutation) Seq() (r string, exists bool) {
	v := m.seq
	if v == nil {
		return
	}
	return *v, true
}

// OldSeq returns the old "seq" field's value of the Scaffold entity.
// If the Scaffold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScaffoldMutation) OldSeq(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeq is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeq requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeq: %w", err)
	}
	return oldValue.Seq, nil
}

// ResetSeq resets all changes to the "seq" field.
func (m *ScaffoldMutation) ResetSeq() {
	m.seq = nil
}

// SetGenomeID sets the "genome" edge to the Genome entity by id.
func (m *ScaffoldMutation) SetGenomeID(id string) {
	m.genome = &id
}

// ClearGenome clears the "genome" edge to the Genome entity.
func (m *ScaffoldMutation) ClearGenome() {
	m.clearedgenome = true
}

// GenomeCleared reports if the "genome" edge to the Genome entity was cleared.
func (m *ScaffoldMutation) GenomeCleared() bool {
	return m.clearedgenome
}

// GenomeID returns the "genome" edge ID in the mutation.
func (m *ScaffoldMutation) GenomeID() (id string, exists bool) {
	if m.genome != nil {
		return *m.genome, true
	}
	return
}

// GenomeIDs returns the "genome" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenomeID instead. It exists only for internal usage by the builders.
func (m *ScaffoldMutation) GenomeIDs() (ids []string) {
	if id := m.genome; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenome resets all changes to the "genome" edge.
func (m *ScaffoldMutation) ResetGenome() {
	m.genome = nil
	m.clearedgenome = false
}

// Where appends a list predicates to the ScaffoldMutation builder.
func (m *ScaffoldMutation) Where(ps ...predicate.Scaffold) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ScaffoldMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Scaffold).
func (m *ScaffoldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScaffoldMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.seqname != nil {
		fields = append(fields, scaffold.FieldSeqname)
	}
	if m.seq != nil {
		fields = append(fields, scaffold.FieldSeq)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScaffoldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scaffold.FieldSeqname:
		return m.Seqname()
	case scaffold.FieldSeq:
		return m.Seq()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScaffoldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scaffold.FieldSeqname:
		return m.OldSeqname(ctx)
	case scaffold.FieldSeq:
		return m.OldSeq(ctx)
	}
	return nil, fmt.Errorf("unknown Scaffold field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScaffoldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scaffold.FieldSeqname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqname(v)
		return nil
	case scaffold.FieldSeq:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeq(v)
		return nil
	}
	return fmt.Errorf("unknown Scaffold field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScaffoldMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScaffoldMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScaffoldMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Scaffold numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScaffoldMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScaffoldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScaffoldMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Scaffold nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScaffoldMutation) ResetField(name string) error {
	switch name {
	case scaffold.FieldSeqname:
		m.ResetSeqname()
		return nil
	case scaffold.FieldSeq:
		m.ResetSeq()
		return nil
	}
	return fmt.Errorf("unknown Scaffold field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScaffoldMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.genome != nil {
		edges = append(edges, scaffold.EdgeGenome)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScaffoldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scaffold.EdgeGenome:
		if id := m.genome; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScaffoldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScaffoldMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScaffoldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgenome {
		edges = append(edges, scaffold.EdgeGenome)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScaffoldMutation) EdgeCleared(name string) bool {
	switch name {
	case scaffold.EdgeGenome:
		return m.clearedgenome
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScaffoldMutation) ClearEdge(name string) error {
	switch name {
	case scaffold.EdgeGenome:
		m.ClearGenome()
		return nil
	}
	return fmt.Errorf("unknown Scaffold unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScaffoldMutation) ResetEdge(name string) error {
	switch name {
	case scaffold.EdgeGenome:
		m.ResetGenome()
		return nil
	}
	return fmt.Errorf("unknown Scaffold edge %s", name)
}

// ThreePrimeUtrMutation represents an operation that mutates the ThreePrimeUtr nodes in the graph.
type ThreePrimeUtrMutation struct {
	config
	op                Op
	typ               string
	id                *int
	seqname           *string
	start             *int32
	addstart          *int32
	end               *int32
	addend            *int32
	strand            *string
	clearedFields     map[string]struct{}
	transcript        *string
	clearedtranscript bool
	done              bool
	oldValue          func(context.Context) (*ThreePrimeUtr, error)
	predicates        []predicate.ThreePrimeUtr
}

var _ ent.Mutation = (*ThreePrimeUtrMutation)(nil)

// threeprimeutrOption allows management of the mutation configuration using functional options.
type threeprimeutrOption func(*ThreePrimeUtrMutation)

// newThreePrimeUtrMutation creates new mutation for the ThreePrimeUtr entity.
func newThreePrimeUtrMutation(c config, op Op, opts ...threeprimeutrOption) *ThreePrimeUtrMutation {
	m := &ThreePrimeUtrMutation{
		config:        c,
		op:            op,
		typ:           TypeThreePrimeUtr,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThreePrimeUtrID sets the ID field of the mutation.
func withThreePrimeUtrID(id int) threeprimeutrOption {
	return func(m *ThreePrimeUtrMutation) {
		var (
			err   error
			once  sync.Once
			value *ThreePrimeUtr
		)
		m.oldValue = func(ctx context.Context) (*ThreePrimeUtr, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ThreePrimeUtr.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withThreePrimeUtr sets the old ThreePrimeUtr of the mutation.
func withThreePrimeUtr(node *ThreePrimeUtr) threeprimeutrOption {
	return func(m *ThreePrimeUtrMutation) {
		m.oldValue = func(context.Context) (*ThreePrimeUtr, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThreePrimeUtrMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThreePrimeUtrMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThreePrimeUtrMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ThreePrimeUtrMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ThreePrimeUtr.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeqname sets the "seqname" field.
func (m *ThreePrimeUtrMutation) SetSeqname(s string) {
	m.seqname = &s
}

// Seqname returns the value of the "seqname" field in the mutation.
func (m *ThreePrimeUtrMutation) Seqname() (r string, exists bool) {
	v := m.seqname
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqname returns the old "seqname" field's value of the ThreePrimeUtr entity.
// If the ThreePrimeUtr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreePrimeUtrMutation) OldSeqname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeqname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeqname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqname: %w", err)
	}
	return oldValue.Seqname, nil
}

// ResetSeqname resets all changes to the "seqname" field.
func (m *ThreePrimeUtrMutation) ResetSeqname() {
	m.seqname = nil
}

// SetStart sets the "start" field.
func (m *ThreePrimeUtrMutation) SetStart(i int32) {
	m.start = &i
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *ThreePrimeUtrMutation) Start() (r int32, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the ThreePrimeUtr entity.
// If the ThreePrimeUtr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreePrimeUtrMutation) OldStart(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds i to the "start" field.
func (m *ThreePrimeUtrMutation) AddStart(i int32) {
	if m.addstart != nil {
		*m.addstart += i
	} else {
		m.addstart = &i
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *ThreePrimeUtrMutation) AddedStart() (r int32, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *ThreePrimeUtrMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *ThreePrimeUtrMutation) SetEnd(i int32) {
	m.end = &i
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *ThreePrimeUtrMutation) End() (r int32, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the ThreePrimeUtr entity.
// If the ThreePrimeUtr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreePrimeUtrMutation) OldEnd(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds i to the "end" field.
func (m *ThreePrimeUtrMutation) AddEnd(i int32) {
	if m.addend != nil {
		*m.addend += i
	} else {
		m.addend = &i
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *ThreePrimeUtrMutation) AddedEnd() (r int32, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *ThreePrimeUtrMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetStrand sets the "strand" field.
func (m *ThreePrimeUtrMutation) SetStrand(s string) {
	m.strand = &s
}

// Strand returns the value of the "strand" field in the mutation.
func (m *ThreePrimeUtrMutation) Strand() (r string, exists bool) {
	v := m.strand
	if v == nil {
		return
	}
	return *v, true
}

// OldStrand returns the old "strand" field's value of the ThreePrimeUtr entity.
// If the ThreePrimeUtr object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThreePrimeUtrMutation) OldStrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrand: %w", err)
	}
	return oldValue.Strand, nil
}

// ResetStrand resets all changes to the "strand" field.
func (m *ThreePrimeUtrMutation) ResetStrand() {
	m.strand = nil
}

// SetTranscriptID sets the "transcript" edge to the Transcript entity by id.
func (m *ThreePrimeUtrMutation) SetTranscriptID(id string) {
	m.transcript = &id
}

// ClearTranscript clears the "transcript" edge to the Transcript entity.
func (m *ThreePrimeUtrMutation) ClearTranscript() {
	m.clearedtranscript = true
}

// TranscriptCleared reports if the "transcript" edge to the Transcript entity was cleared.
func (m *ThreePrimeUtrMutation) TranscriptCleared() bool {
	return m.clearedtranscript
}

// TranscriptID returns the "transcript" edge ID in the mutation.
func (m *ThreePrimeUtrMutation) TranscriptID() (id string, exists bool) {
	if m.transcript != nil {
		return *m.transcript, true
	}
	return
}

// TranscriptIDs returns the "transcript" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TranscriptID instead. It exists only for internal usage by the builders.
func (m *ThreePrimeUtrMutation) TranscriptIDs() (ids []string) {
	if id := m.transcript; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTranscript resets all changes to the "transcript" edge.
func (m *ThreePrimeUtrMutation) ResetTranscript() {
	m.transcript = nil
	m.clearedtranscript = false
}

// Where appends a list predicates to the ThreePrimeUtrMutation builder.
func (m *ThreePrimeUtrMutation) Where(ps ...predicate.ThreePrimeUtr) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ThreePrimeUtrMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ThreePrimeUtr).
func (m *ThreePrimeUtrMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThreePrimeUtrMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.seqname != nil {
		fields = append(fields, threeprimeutr.FieldSeqname)
	}
	if m.start != nil {
		fields = append(fields, threeprimeutr.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, threeprimeutr.FieldEnd)
	}
	if m.strand != nil {
		fields = append(fields, threeprimeutr.FieldStrand)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThreePrimeUtrMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case threeprimeutr.FieldSeqname:
		return m.Seqname()
	case threeprimeutr.FieldStart:
		return m.Start()
	case threeprimeutr.FieldEnd:
		return m.End()
	case threeprimeutr.FieldStrand:
		return m.Strand()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThreePrimeUtrMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case threeprimeutr.FieldSeqname:
		return m.OldSeqname(ctx)
	case threeprimeutr.FieldStart:
		return m.OldStart(ctx)
	case threeprimeutr.FieldEnd:
		return m.OldEnd(ctx)
	case threeprimeutr.FieldStrand:
		return m.OldStrand(ctx)
	}
	return nil, fmt.Errorf("unknown ThreePrimeUtr field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreePrimeUtrMutation) SetField(name string, value ent.Value) error {
	switch name {
	case threeprimeutr.FieldSeqname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqname(v)
		return nil
	case threeprimeutr.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case threeprimeutr.FieldEnd:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case threeprimeutr.FieldStrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrand(v)
		return nil
	}
	return fmt.Errorf("unknown ThreePrimeUtr field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThreePrimeUtrMutation) AddedFields() []string {
	var fields []string
	if m.addstart != nil {
		fields = append(fields, threeprimeutr.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, threeprimeutr.FieldEnd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThreePrimeUtrMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case threeprimeutr.FieldStart:
		return m.AddedStart()
	case threeprimeutr.FieldEnd:
		return m.AddedEnd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThreePrimeUtrMutation) AddField(name string, value ent.Value) error {
	switch name {
	case threeprimeutr.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case threeprimeutr.FieldEnd:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	}
	return fmt.Errorf("unknown ThreePrimeUtr numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThreePrimeUtrMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThreePrimeUtrMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThreePrimeUtrMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ThreePrimeUtr nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThreePrimeUtrMutation) ResetField(name string) error {
	switch name {
	case threeprimeutr.FieldSeqname:
		m.ResetSeqname()
		return nil
	case threeprimeutr.FieldStart:
		m.ResetStart()
		return nil
	case threeprimeutr.FieldEnd:
		m.ResetEnd()
		return nil
	case threeprimeutr.FieldStrand:
		m.ResetStrand()
		return nil
	}
	return fmt.Errorf("unknown ThreePrimeUtr field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThreePrimeUtrMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transcript != nil {
		edges = append(edges, threeprimeutr.EdgeTranscript)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThreePrimeUtrMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case threeprimeutr.EdgeTranscript:
		if id := m.transcript; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThreePrimeUtrMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThreePrimeUtrMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThreePrimeUtrMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtranscript {
		edges = append(edges, threeprimeutr.EdgeTranscript)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThreePrimeUtrMutation) EdgeCleared(name string) bool {
	switch name {
	case threeprimeutr.EdgeTranscript:
		return m.clearedtranscript
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThreePrimeUtrMutation) ClearEdge(name string) error {
	switch name {
	case threeprimeutr.EdgeTranscript:
		m.ClearTranscript()
		return nil
	}
	return fmt.Errorf("unknown ThreePrimeUtr unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThreePrimeUtrMutation) ResetEdge(name string) error {
	switch name {
	case threeprimeutr.EdgeTranscript:
		m.ResetTranscript()
		return nil
	}
	return fmt.Errorf("unknown ThreePrimeUtr edge %s", name)
}

// TranscriptMutation represents an operation that mutates the Transcript nodes in the graph.
type TranscriptMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	strand                 *string
	_type                  *string
	genome_seq             *string
	transcript_seq         *string
	cds_seq                *string
	protein_seq            *string
	clearedFields          map[string]struct{}
	gene                   *string
	clearedgene            bool
	cds                    map[int]struct{}
	removedcds             map[int]struct{}
	clearedcds             bool
	exon                   map[int]struct{}
	removedexon            map[int]struct{}
	clearedexon            bool
	five_prime_utr         map[int]struct{}
	removedfive_prime_utr  map[int]struct{}
	clearedfive_prime_utr  bool
	three_prime_utr        map[int]struct{}
	removedthree_prime_utr map[int]struct{}
	clearedthree_prime_utr bool
	done                   bool
	oldValue               func(context.Context) (*Transcript, error)
	predicates             []predicate.Transcript
}

var _ ent.Mutation = (*TranscriptMutation)(nil)

// transcriptOption allows management of the mutation configuration using functional options.
type transcriptOption func(*TranscriptMutation)

// newTranscriptMutation creates new mutation for the Transcript entity.
func newTranscriptMutation(c config, op Op, opts ...transcriptOption) *TranscriptMutation {
	m := &TranscriptMutation{
		config:        c,
		op:            op,
		typ:           TypeTranscript,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTranscriptID sets the ID field of the mutation.
func withTranscriptID(id string) transcriptOption {
	return func(m *TranscriptMutation) {
		var (
			err   error
			once  sync.Once
			value *Transcript
		)
		m.oldValue = func(ctx context.Context) (*Transcript, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transcript.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTranscript sets the old Transcript of the mutation.
func withTranscript(node *Transcript) transcriptOption {
	return func(m *TranscriptMutation) {
		m.oldValue = func(context.Context) (*Transcript, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TranscriptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TranscriptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transcript entities.
func (m *TranscriptMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TranscriptMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TranscriptMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transcript.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStrand sets the "strand" field.
func (m *TranscriptMutation) SetStrand(s string) {
	m.strand = &s
}

// Strand returns the value of the "strand" field in the mutation.
func (m *TranscriptMutation) Strand() (r string, exists bool) {
	v := m.strand
	if v == nil {
		return
	}
	return *v, true
}

// OldStrand returns the old "strand" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldStrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrand: %w", err)
	}
	return oldValue.Strand, nil
}

// ResetStrand resets all changes to the "strand" field.
func (m *TranscriptMutation) ResetStrand() {
	m.strand = nil
}

// SetType sets the "type" field.
func (m *TranscriptMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TranscriptMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TranscriptMutation) ResetType() {
	m._type = nil
}

// SetGenomeSeq sets the "genome_seq" field.
func (m *TranscriptMutation) SetGenomeSeq(s string) {
	m.genome_seq = &s
}

// GenomeSeq returns the value of the "genome_seq" field in the mutation.
func (m *TranscriptMutation) GenomeSeq() (r string, exists bool) {
	v := m.genome_seq
	if v == nil {
		return
	}
	return *v, true
}

// OldGenomeSeq returns the old "genome_seq" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldGenomeSeq(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenomeSeq is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenomeSeq requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenomeSeq: %w", err)
	}
	return oldValue.GenomeSeq, nil
}

// ResetGenomeSeq resets all changes to the "genome_seq" field.
func (m *TranscriptMutation) ResetGenomeSeq() {
	m.genome_seq = nil
}

// SetTranscriptSeq sets the "transcript_seq" field.
func (m *TranscriptMutation) SetTranscriptSeq(s string) {
	m.transcript_seq = &s
}

// TranscriptSeq returns the value of the "transcript_seq" field in the mutation.
func (m *TranscriptMutation) TranscriptSeq() (r string, exists bool) {
	v := m.transcript_seq
	if v == nil {
		return
	}
	return *v, true
}

// OldTranscriptSeq returns the old "transcript_seq" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldTranscriptSeq(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTranscriptSeq is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTranscriptSeq requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTranscriptSeq: %w", err)
	}
	return oldValue.TranscriptSeq, nil
}

// ResetTranscriptSeq resets all changes to the "transcript_seq" field.
func (m *TranscriptMutation) ResetTranscriptSeq() {
	m.transcript_seq = nil
}

// SetCdsSeq sets the "cds_seq" field.
func (m *TranscriptMutation) SetCdsSeq(s string) {
	m.cds_seq = &s
}

// CdsSeq returns the value of the "cds_seq" field in the mutation.
func (m *TranscriptMutation) CdsSeq() (r string, exists bool) {
	v := m.cds_seq
	if v == nil {
		return
	}
	return *v, true
}

// OldCdsSeq returns the old "cds_seq" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldCdsSeq(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCdsSeq is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCdsSeq requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCdsSeq: %w", err)
	}
	return oldValue.CdsSeq, nil
}

// ResetCdsSeq resets all changes to the "cds_seq" field.
func (m *TranscriptMutation) ResetCdsSeq() {
	m.cds_seq = nil
}

// SetProteinSeq sets the "protein_seq" field.
func (m *TranscriptMutation) SetProteinSeq(s string) {
	m.protein_seq = &s
}

// ProteinSeq returns the value of the "protein_seq" field in the mutation.
func (m *TranscriptMutation) ProteinSeq() (r string, exists bool) {
	v := m.protein_seq
	if v == nil {
		return
	}
	return *v, true
}

// OldProteinSeq returns the old "protein_seq" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldProteinSeq(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProteinSeq is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProteinSeq requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProteinSeq: %w", err)
	}
	return oldValue.ProteinSeq, nil
}

// ResetProteinSeq resets all changes to the "protein_seq" field.
func (m *TranscriptMutation) ResetProteinSeq() {
	m.protein_seq = nil
}

// SetGeneID sets the "gene" edge to the Gene entity by id.
func (m *TranscriptMutation) SetGeneID(id string) {
	m.gene = &id
}

// ClearGene clears the "gene" edge to the Gene entity.
func (m *TranscriptMutation) ClearGene() {
	m.clearedgene = true
}

// GeneCleared reports if the "gene" edge to the Gene entity was cleared.
func (m *TranscriptMutation) GeneCleared() bool {
	return m.clearedgene
}

// GeneID returns the "gene" edge ID in the mutation.
func (m *TranscriptMutation) GeneID() (id string, exists bool) {
	if m.gene != nil {
		return *m.gene, true
	}
	return
}

// GeneIDs returns the "gene" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GeneID instead. It exists only for internal usage by the builders.
func (m *TranscriptMutation) GeneIDs() (ids []string) {
	if id := m.gene; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGene resets all changes to the "gene" edge.
func (m *TranscriptMutation) ResetGene() {
	m.gene = nil
	m.clearedgene = false
}

// AddCdIDs adds the "cds" edge to the Cds entity by ids.
func (m *TranscriptMutation) AddCdIDs(ids ...int) {
	if m.cds == nil {
		m.cds = make(map[int]struct{})
	}
	for i := range ids {
		m.cds[ids[i]] = struct{}{}
	}
}

// ClearCds clears the "cds" edge to the Cds entity.
func (m *TranscriptMutation) ClearCds() {
	m.clearedcds = true
}

// CdsCleared reports if the "cds" edge to the Cds entity was cleared.
func (m *TranscriptMutation) CdsCleared() bool {
	return m.clearedcds
}

// RemoveCdIDs removes the "cds" edge to the Cds entity by IDs.
func (m *TranscriptMutation) RemoveCdIDs(ids ...int) {
	if m.removedcds == nil {
		m.removedcds = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cds, ids[i])
		m.removedcds[ids[i]] = struct{}{}
	}
}

// RemovedCds returns the removed IDs of the "cds" edge to the Cds entity.
func (m *TranscriptMutation) RemovedCdsIDs() (ids []int) {
	for id := range m.removedcds {
		ids = append(ids, id)
	}
	return
}

// CdsIDs returns the "cds" edge IDs in the mutation.
func (m *TranscriptMutation) CdsIDs() (ids []int) {
	for id := range m.cds {
		ids = append(ids, id)
	}
	return
}

// ResetCds resets all changes to the "cds" edge.
func (m *TranscriptMutation) ResetCds() {
	m.cds = nil
	m.clearedcds = false
	m.removedcds = nil
}

// AddExonIDs adds the "exon" edge to the Exon entity by ids.
func (m *TranscriptMutation) AddExonIDs(ids ...int) {
	if m.exon == nil {
		m.exon = make(map[int]struct{})
	}
	for i := range ids {
		m.exon[ids[i]] = struct{}{}
	}
}

// ClearExon clears the "exon" edge to the Exon entity.
func (m *TranscriptMutation) ClearExon() {
	m.clearedexon = true
}

// ExonCleared reports if the "exon" edge to the Exon entity was cleared.
func (m *TranscriptMutation) ExonCleared() bool {
	return m.clearedexon
}

// RemoveExonIDs removes the "exon" edge to the Exon entity by IDs.
func (m *TranscriptMutation) RemoveExonIDs(ids ...int) {
	if m.removedexon == nil {
		m.removedexon = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.exon, ids[i])
		m.removedexon[ids[i]] = struct{}{}
	}
}

// RemovedExon returns the removed IDs of the "exon" edge to the Exon entity.
func (m *TranscriptMutation) RemovedExonIDs() (ids []int) {
	for id := range m.removedexon {
		ids = append(ids, id)
	}
	return
}

// ExonIDs returns the "exon" edge IDs in the mutation.
func (m *TranscriptMutation) ExonIDs() (ids []int) {
	for id := range m.exon {
		ids = append(ids, id)
	}
	return
}

// ResetExon resets all changes to the "exon" edge.
func (m *TranscriptMutation) ResetExon() {
	m.exon = nil
	m.clearedexon = false
	m.removedexon = nil
}

// AddFivePrimeUtrIDs adds the "five_prime_utr" edge to the FivePrimeUtr entity by ids.
func (m *TranscriptMutation) AddFivePrimeUtrIDs(ids ...int) {
	if m.five_prime_utr == nil {
		m.five_prime_utr = make(map[int]struct{})
	}
	for i := range ids {
		m.five_prime_utr[ids[i]] = struct{}{}
	}
}

// ClearFivePrimeUtr clears the "five_prime_utr" edge to the FivePrimeUtr entity.
func (m *TranscriptMutation) ClearFivePrimeUtr() {
	m.clearedfive_prime_utr = true
}

// FivePrimeUtrCleared reports if the "five_prime_utr" edge to the FivePrimeUtr entity was cleared.
func (m *TranscriptMutation) FivePrimeUtrCleared() bool {
	return m.clearedfive_prime_utr
}

// RemoveFivePrimeUtrIDs removes the "five_prime_utr" edge to the FivePrimeUtr entity by IDs.
func (m *TranscriptMutation) RemoveFivePrimeUtrIDs(ids ...int) {
	if m.removedfive_prime_utr == nil {
		m.removedfive_prime_utr = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.five_prime_utr, ids[i])
		m.removedfive_prime_utr[ids[i]] = struct{}{}
	}
}

// RemovedFivePrimeUtr returns the removed IDs of the "five_prime_utr" edge to the FivePrimeUtr entity.
func (m *TranscriptMutation) RemovedFivePrimeUtrIDs() (ids []int) {
	for id := range m.removedfive_prime_utr {
		ids = append(ids, id)
	}
	return
}

// FivePrimeUtrIDs returns the "five_prime_utr" edge IDs in the mutation.
func (m *TranscriptMutation) FivePrimeUtrIDs() (ids []int) {
	for id := range m.five_prime_utr {
		ids = append(ids, id)
	}
	return
}

// ResetFivePrimeUtr resets all changes to the "five_prime_utr" edge.
func (m *TranscriptMutation) ResetFivePrimeUtr() {
	m.five_prime_utr = nil
	m.clearedfive_prime_utr = false
	m.removedfive_prime_utr = nil
}

// AddThreePrimeUtrIDs adds the "three_prime_utr" edge to the ThreePrimeUtr entity by ids.
func (m *TranscriptMutation) AddThreePrimeUtrIDs(ids ...int) {
	if m.three_prime_utr == nil {
		m.three_prime_utr = make(map[int]struct{})
	}
	for i := range ids {
		m.three_prime_utr[ids[i]] = struct{}{}
	}
}

// ClearThreePrimeUtr clears the "three_prime_utr" edge to the ThreePrimeUtr entity.
func (m *TranscriptMutation) ClearThreePrimeUtr() {
	m.clearedthree_prime_utr = true
}

// ThreePrimeUtrCleared reports if the "three_prime_utr" edge to the ThreePrimeUtr entity was cleared.
func (m *TranscriptMutation) ThreePrimeUtrCleared() bool {
	return m.clearedthree_prime_utr
}

// RemoveThreePrimeUtrIDs removes the "three_prime_utr" edge to the ThreePrimeUtr entity by IDs.
func (m *TranscriptMutation) RemoveThreePrimeUtrIDs(ids ...int) {
	if m.removedthree_prime_utr == nil {
		m.removedthree_prime_utr = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.three_prime_utr, ids[i])
		m.removedthree_prime_utr[ids[i]] = struct{}{}
	}
}

// RemovedThreePrimeUtr returns the removed IDs of the "three_prime_utr" edge to the ThreePrimeUtr entity.
func (m *TranscriptMutation) RemovedThreePrimeUtrIDs() (ids []int) {
	for id := range m.removedthree_prime_utr {
		ids = append(ids, id)
	}
	return
}

// ThreePrimeUtrIDs returns the "three_prime_utr" edge IDs in the mutation.
func (m *TranscriptMutation) ThreePrimeUtrIDs() (ids []int) {
	for id := range m.three_prime_utr {
		ids = append(ids, id)
	}
	return
}

// ResetThreePrimeUtr resets all changes to the "three_prime_utr" edge.
func (m *TranscriptMutation) ResetThreePrimeUtr() {
	m.three_prime_utr = nil
	m.clearedthree_prime_utr = false
	m.removedthree_prime_utr = nil
}

// Where appends a list predicates to the TranscriptMutation builder.
func (m *TranscriptMutation) Where(ps ...predicate.Transcript) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TranscriptMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transcript).
func (m *TranscriptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TranscriptMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.strand != nil {
		fields = append(fields, transcript.FieldStrand)
	}
	if m._type != nil {
		fields = append(fields, transcript.FieldType)
	}
	if m.genome_seq != nil {
		fields = append(fields, transcript.FieldGenomeSeq)
	}
	if m.transcript_seq != nil {
		fields = append(fields, transcript.FieldTranscriptSeq)
	}
	if m.cds_seq != nil {
		fields = append(fields, transcript.FieldCdsSeq)
	}
	if m.protein_seq != nil {
		fields = append(fields, transcript.FieldProteinSeq)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TranscriptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transcript.FieldStrand:
		return m.Strand()
	case transcript.FieldType:
		return m.GetType()
	case transcript.FieldGenomeSeq:
		return m.GenomeSeq()
	case transcript.FieldTranscriptSeq:
		return m.TranscriptSeq()
	case transcript.FieldCdsSeq:
		return m.CdsSeq()
	case transcript.FieldProteinSeq:
		return m.ProteinSeq()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TranscriptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transcript.FieldStrand:
		return m.OldStrand(ctx)
	case transcript.FieldType:
		return m.OldType(ctx)
	case transcript.FieldGenomeSeq:
		return m.OldGenomeSeq(ctx)
	case transcript.FieldTranscriptSeq:
		return m.OldTranscriptSeq(ctx)
	case transcript.FieldCdsSeq:
		return m.OldCdsSeq(ctx)
	case transcript.FieldProteinSeq:
		return m.OldProteinSeq(ctx)
	}
	return nil, fmt.Errorf("unknown Transcript field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TranscriptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transcript.FieldStrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrand(v)
		return nil
	case transcript.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transcript.FieldGenomeSeq:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenomeSeq(v)
		return nil
	case transcript.FieldTranscriptSeq:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTranscriptSeq(v)
		return nil
	case transcript.FieldCdsSeq:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCdsSeq(v)
		return nil
	case transcript.FieldProteinSeq:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProteinSeq(v)
		return nil
	}
	return fmt.Errorf("unknown Transcript field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TranscriptMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TranscriptMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TranscriptMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Transcript numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TranscriptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TranscriptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TranscriptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Transcript nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TranscriptMutation) ResetField(name string) error {
	switch name {
	case transcript.FieldStrand:
		m.ResetStrand()
		return nil
	case transcript.FieldType:
		m.ResetType()
		return nil
	case transcript.FieldGenomeSeq:
		m.ResetGenomeSeq()
		return nil
	case transcript.FieldTranscriptSeq:
		m.ResetTranscriptSeq()
		return nil
	case transcript.FieldCdsSeq:
		m.ResetCdsSeq()
		return nil
	case transcript.FieldProteinSeq:
		m.ResetProteinSeq()
		return nil
	}
	return fmt.Errorf("unknown Transcript field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TranscriptMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.gene != nil {
		edges = append(edges, transcript.EdgeGene)
	}
	if m.cds != nil {
		edges = append(edges, transcript.EdgeCds)
	}
	if m.exon != nil {
		edges = append(edges, transcript.EdgeExon)
	}
	if m.five_prime_utr != nil {
		edges = append(edges, transcript.EdgeFivePrimeUtr)
	}
	if m.three_prime_utr != nil {
		edges = append(edges, transcript.EdgeThreePrimeUtr)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TranscriptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transcript.EdgeGene:
		if id := m.gene; id != nil {
			return []ent.Value{*id}
		}
	case transcript.EdgeCds:
		ids := make([]ent.Value, 0, len(m.cds))
		for id := range m.cds {
			ids = append(ids, id)
		}
		return ids
	case transcript.EdgeExon:
		ids := make([]ent.Value, 0, len(m.exon))
		for id := range m.exon {
			ids = append(ids, id)
		}
		return ids
	case transcript.EdgeFivePrimeUtr:
		ids := make([]ent.Value, 0, len(m.five_prime_utr))
		for id := range m.five_prime_utr {
			ids = append(ids, id)
		}
		return ids
	case transcript.EdgeThreePrimeUtr:
		ids := make([]ent.Value, 0, len(m.three_prime_utr))
		for id := range m.three_prime_utr {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TranscriptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcds != nil {
		edges = append(edges, transcript.EdgeCds)
	}
	if m.removedexon != nil {
		edges = append(edges, transcript.EdgeExon)
	}
	if m.removedfive_prime_utr != nil {
		edges = append(edges, transcript.EdgeFivePrimeUtr)
	}
	if m.removedthree_prime_utr != nil {
		edges = append(edges, transcript.EdgeThreePrimeUtr)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TranscriptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transcript.EdgeCds:
		ids := make([]ent.Value, 0, len(m.removedcds))
		for id := range m.removedcds {
			ids = append(ids, id)
		}
		return ids
	case transcript.EdgeExon:
		ids := make([]ent.Value, 0, len(m.removedexon))
		for id := range m.removedexon {
			ids = append(ids, id)
		}
		return ids
	case transcript.EdgeFivePrimeUtr:
		ids := make([]ent.Value, 0, len(m.removedfive_prime_utr))
		for id := range m.removedfive_prime_utr {
			ids = append(ids, id)
		}
		return ids
	case transcript.EdgeThreePrimeUtr:
		ids := make([]ent.Value, 0, len(m.removedthree_prime_utr))
		for id := range m.removedthree_prime_utr {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TranscriptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedgene {
		edges = append(edges, transcript.EdgeGene)
	}
	if m.clearedcds {
		edges = append(edges, transcript.EdgeCds)
	}
	if m.clearedexon {
		edges = append(edges, transcript.EdgeExon)
	}
	if m.clearedfive_prime_utr {
		edges = append(edges, transcript.EdgeFivePrimeUtr)
	}
	if m.clearedthree_prime_utr {
		edges = append(edges, transcript.EdgeThreePrimeUtr)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TranscriptMutation) EdgeCleared(name string) bool {
	switch name {
	case transcript.EdgeGene:
		return m.clearedgene
	case transcript.EdgeCds:
		return m.clearedcds
	case transcript.EdgeExon:
		return m.clearedexon
	case transcript.EdgeFivePrimeUtr:
		return m.clearedfive_prime_utr
	case transcript.EdgeThreePrimeUtr:
		return m.clearedthree_prime_utr
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TranscriptMutation) ClearEdge(name string) error {
	switch name {
	case transcript.EdgeGene:
		m.ClearGene()
		return nil
	}
	return fmt.Errorf("unknown Transcript unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TranscriptMutation) ResetEdge(name string) error {
	switch name {
	case transcript.EdgeGene:
		m.ResetGene()
		return nil
	case transcript.EdgeCds:
		m.ResetCds()
		return nil
	case transcript.EdgeExon:
		m.ResetExon()
		return nil
	case transcript.EdgeFivePrimeUtr:
		m.ResetFivePrimeUtr()
		return nil
	case transcript.EdgeThreePrimeUtr:
		m.ResetThreePrimeUtr()
		return nil
	}
	return fmt.Errorf("unknown Transcript edge %s", name)
}
