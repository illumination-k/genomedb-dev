// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"genomedb/bio/gffio"
	"genomedb/ent/domainannotation"
	"genomedb/ent/domainannotationtotranscript"
	"genomedb/ent/genome"
	"genomedb/ent/goterm"
	"genomedb/ent/gotermontranscripts"
	"genomedb/ent/keggontology"
	"genomedb/ent/locus"
	"genomedb/ent/predicate"
	"genomedb/ent/scaffold"
	"genomedb/ent/transcript"
	"sync"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDomainAnnotation             = "DomainAnnotation"
	TypeDomainAnnotationToTranscript = "DomainAnnotationToTranscript"
	TypeGenome                       = "Genome"
	TypeGoTerm                       = "GoTerm"
	TypeGoTermOnTranscripts          = "GoTermOnTranscripts"
	TypeKeggCompound                 = "KeggCompound"
	TypeKeggModule                   = "KeggModule"
	TypeKeggOntology                 = "KeggOntology"
	TypeKeggPathway                  = "KeggPathway"
	TypeKeggReaction                 = "KeggReaction"
	TypeLocus                        = "Locus"
	TypeScaffold                     = "Scaffold"
	TypeTranscript                   = "Transcript"
)

// DomainAnnotationMutation represents an operation that mutates the DomainAnnotation nodes in the graph.
type DomainAnnotationMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	description        *string
	_Analysis          *domainannotation.Analysis
	clearedFields      map[string]struct{}
	transcripts        map[string]struct{}
	removedtranscripts map[string]struct{}
	clearedtranscripts bool
	done               bool
	oldValue           func(context.Context) (*DomainAnnotation, error)
	predicates         []predicate.DomainAnnotation
}

var _ ent.Mutation = (*DomainAnnotationMutation)(nil)

// domainannotationOption allows management of the mutation configuration using functional options.
type domainannotationOption func(*DomainAnnotationMutation)

// newDomainAnnotationMutation creates new mutation for the DomainAnnotation entity.
func newDomainAnnotationMutation(c config, op Op, opts ...domainannotationOption) *DomainAnnotationMutation {
	m := &DomainAnnotationMutation{
		config:        c,
		op:            op,
		typ:           TypeDomainAnnotation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDomainAnnotationID sets the ID field of the mutation.
func withDomainAnnotationID(id string) domainannotationOption {
	return func(m *DomainAnnotationMutation) {
		var (
			err   error
			once  sync.Once
			value *DomainAnnotation
		)
		m.oldValue = func(ctx context.Context) (*DomainAnnotation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DomainAnnotation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDomainAnnotation sets the old DomainAnnotation of the mutation.
func withDomainAnnotation(node *DomainAnnotation) domainannotationOption {
	return func(m *DomainAnnotationMutation) {
		m.oldValue = func(context.Context) (*DomainAnnotation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DomainAnnotationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DomainAnnotationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DomainAnnotation entities.
func (m *DomainAnnotationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DomainAnnotationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DomainAnnotationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DomainAnnotation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescription sets the "description" field.
func (m *DomainAnnotationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DomainAnnotationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DomainAnnotation entity.
// If the DomainAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainAnnotationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DomainAnnotationMutation) ResetDescription() {
	m.description = nil
}

// SetAnalysis sets the "Analysis" field.
func (m *DomainAnnotationMutation) SetAnalysis(d domainannotation.Analysis) {
	m._Analysis = &d
}

// Analysis returns the value of the "Analysis" field in the mutation.
func (m *DomainAnnotationMutation) Analysis() (r domainannotation.Analysis, exists bool) {
	v := m._Analysis
	if v == nil {
		return
	}
	return *v, true
}

// OldAnalysis returns the old "Analysis" field's value of the DomainAnnotation entity.
// If the DomainAnnotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DomainAnnotationMutation) OldAnalysis(ctx context.Context) (v domainannotation.Analysis, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnalysis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnalysis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnalysis: %w", err)
	}
	return oldValue.Analysis, nil
}

// ResetAnalysis resets all changes to the "Analysis" field.
func (m *DomainAnnotationMutation) ResetAnalysis() {
	m._Analysis = nil
}

// AddTranscriptIDs adds the "transcripts" edge to the Transcript entity by ids.
func (m *DomainAnnotationMutation) AddTranscriptIDs(ids ...string) {
	if m.transcripts == nil {
		m.transcripts = make(map[string]struct{})
	}
	for i := range ids {
		m.transcripts[ids[i]] = struct{}{}
	}
}

// ClearTranscripts clears the "transcripts" edge to the Transcript entity.
func (m *DomainAnnotationMutation) ClearTranscripts() {
	m.clearedtranscripts = true
}

// TranscriptsCleared reports if the "transcripts" edge to the Transcript entity was cleared.
func (m *DomainAnnotationMutation) TranscriptsCleared() bool {
	return m.clearedtranscripts
}

// RemoveTranscriptIDs removes the "transcripts" edge to the Transcript entity by IDs.
func (m *DomainAnnotationMutation) RemoveTranscriptIDs(ids ...string) {
	if m.removedtranscripts == nil {
		m.removedtranscripts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transcripts, ids[i])
		m.removedtranscripts[ids[i]] = struct{}{}
	}
}

// RemovedTranscripts returns the removed IDs of the "transcripts" edge to the Transcript entity.
func (m *DomainAnnotationMutation) RemovedTranscriptsIDs() (ids []string) {
	for id := range m.removedtranscripts {
		ids = append(ids, id)
	}
	return
}

// TranscriptsIDs returns the "transcripts" edge IDs in the mutation.
func (m *DomainAnnotationMutation) TranscriptsIDs() (ids []string) {
	for id := range m.transcripts {
		ids = append(ids, id)
	}
	return
}

// ResetTranscripts resets all changes to the "transcripts" edge.
func (m *DomainAnnotationMutation) ResetTranscripts() {
	m.transcripts = nil
	m.clearedtranscripts = false
	m.removedtranscripts = nil
}

// Where appends a list predicates to the DomainAnnotationMutation builder.
func (m *DomainAnnotationMutation) Where(ps ...predicate.DomainAnnotation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DomainAnnotationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DomainAnnotation).
func (m *DomainAnnotationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DomainAnnotationMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.description != nil {
		fields = append(fields, domainannotation.FieldDescription)
	}
	if m._Analysis != nil {
		fields = append(fields, domainannotation.FieldAnalysis)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DomainAnnotationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case domainannotation.FieldDescription:
		return m.Description()
	case domainannotation.FieldAnalysis:
		return m.Analysis()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DomainAnnotationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case domainannotation.FieldDescription:
		return m.OldDescription(ctx)
	case domainannotation.FieldAnalysis:
		return m.OldAnalysis(ctx)
	}
	return nil, fmt.Errorf("unknown DomainAnnotation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainAnnotationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case domainannotation.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case domainannotation.FieldAnalysis:
		v, ok := value.(domainannotation.Analysis)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnalysis(v)
		return nil
	}
	return fmt.Errorf("unknown DomainAnnotation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DomainAnnotationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DomainAnnotationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainAnnotationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DomainAnnotation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DomainAnnotationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DomainAnnotationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DomainAnnotationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DomainAnnotation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DomainAnnotationMutation) ResetField(name string) error {
	switch name {
	case domainannotation.FieldDescription:
		m.ResetDescription()
		return nil
	case domainannotation.FieldAnalysis:
		m.ResetAnalysis()
		return nil
	}
	return fmt.Errorf("unknown DomainAnnotation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DomainAnnotationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transcripts != nil {
		edges = append(edges, domainannotation.EdgeTranscripts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DomainAnnotationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case domainannotation.EdgeTranscripts:
		ids := make([]ent.Value, 0, len(m.transcripts))
		for id := range m.transcripts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DomainAnnotationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtranscripts != nil {
		edges = append(edges, domainannotation.EdgeTranscripts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DomainAnnotationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case domainannotation.EdgeTranscripts:
		ids := make([]ent.Value, 0, len(m.removedtranscripts))
		for id := range m.removedtranscripts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DomainAnnotationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtranscripts {
		edges = append(edges, domainannotation.EdgeTranscripts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DomainAnnotationMutation) EdgeCleared(name string) bool {
	switch name {
	case domainannotation.EdgeTranscripts:
		return m.clearedtranscripts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DomainAnnotationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DomainAnnotation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DomainAnnotationMutation) ResetEdge(name string) error {
	switch name {
	case domainannotation.EdgeTranscripts:
		m.ResetTranscripts()
		return nil
	}
	return fmt.Errorf("unknown DomainAnnotation edge %s", name)
}

// DomainAnnotationToTranscriptMutation represents an operation that mutates the DomainAnnotationToTranscript nodes in the graph.
type DomainAnnotationToTranscriptMutation struct {
	config
	op                Op
	typ               string
	start             *int32
	addstart          *int32
	stop              *int32
	addstop           *int32
	score             *float64
	addscore          *float64
	clearedFields     map[string]struct{}
	domain            *string
	cleareddomain     bool
	transcript        *string
	clearedtranscript bool
	done              bool
	oldValue          func(context.Context) (*DomainAnnotationToTranscript, error)
	predicates        []predicate.DomainAnnotationToTranscript
}

var _ ent.Mutation = (*DomainAnnotationToTranscriptMutation)(nil)

// domainannotationtotranscriptOption allows management of the mutation configuration using functional options.
type domainannotationtotranscriptOption func(*DomainAnnotationToTranscriptMutation)

// newDomainAnnotationToTranscriptMutation creates new mutation for the DomainAnnotationToTranscript entity.
func newDomainAnnotationToTranscriptMutation(c config, op Op, opts ...domainannotationtotranscriptOption) *DomainAnnotationToTranscriptMutation {
	m := &DomainAnnotationToTranscriptMutation{
		config:        c,
		op:            op,
		typ:           TypeDomainAnnotationToTranscript,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DomainAnnotationToTranscriptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DomainAnnotationToTranscriptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetDomainAnnotationID sets the "domain_annotation_id" field.
func (m *DomainAnnotationToTranscriptMutation) SetDomainAnnotationID(s string) {
	m.domain = &s
}

// DomainAnnotationID returns the value of the "domain_annotation_id" field in the mutation.
func (m *DomainAnnotationToTranscriptMutation) DomainAnnotationID() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// ResetDomainAnnotationID resets all changes to the "domain_annotation_id" field.
func (m *DomainAnnotationToTranscriptMutation) ResetDomainAnnotationID() {
	m.domain = nil
}

// SetTranscriptID sets the "transcript_id" field.
func (m *DomainAnnotationToTranscriptMutation) SetTranscriptID(s string) {
	m.transcript = &s
}

// TranscriptID returns the value of the "transcript_id" field in the mutation.
func (m *DomainAnnotationToTranscriptMutation) TranscriptID() (r string, exists bool) {
	v := m.transcript
	if v == nil {
		return
	}
	return *v, true
}

// ResetTranscriptID resets all changes to the "transcript_id" field.
func (m *DomainAnnotationToTranscriptMutation) ResetTranscriptID() {
	m.transcript = nil
}

// SetStart sets the "start" field.
func (m *DomainAnnotationToTranscriptMutation) SetStart(i int32) {
	m.start = &i
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *DomainAnnotationToTranscriptMutation) Start() (r int32, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// AddStart adds i to the "start" field.
func (m *DomainAnnotationToTranscriptMutation) AddStart(i int32) {
	if m.addstart != nil {
		*m.addstart += i
	} else {
		m.addstart = &i
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *DomainAnnotationToTranscriptMutation) AddedStart() (r int32, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *DomainAnnotationToTranscriptMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetStop sets the "stop" field.
func (m *DomainAnnotationToTranscriptMutation) SetStop(i int32) {
	m.stop = &i
	m.addstop = nil
}

// Stop returns the value of the "stop" field in the mutation.
func (m *DomainAnnotationToTranscriptMutation) Stop() (r int32, exists bool) {
	v := m.stop
	if v == nil {
		return
	}
	return *v, true
}

// AddStop adds i to the "stop" field.
func (m *DomainAnnotationToTranscriptMutation) AddStop(i int32) {
	if m.addstop != nil {
		*m.addstop += i
	} else {
		m.addstop = &i
	}
}

// AddedStop returns the value that was added to the "stop" field in this mutation.
func (m *DomainAnnotationToTranscriptMutation) AddedStop() (r int32, exists bool) {
	v := m.addstop
	if v == nil {
		return
	}
	return *v, true
}

// ResetStop resets all changes to the "stop" field.
func (m *DomainAnnotationToTranscriptMutation) ResetStop() {
	m.stop = nil
	m.addstop = nil
}

// SetScore sets the "score" field.
func (m *DomainAnnotationToTranscriptMutation) SetScore(f float64) {
	m.score = &f
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *DomainAnnotationToTranscriptMutation) Score() (r float64, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// AddScore adds f to the "score" field.
func (m *DomainAnnotationToTranscriptMutation) AddScore(f float64) {
	if m.addscore != nil {
		*m.addscore += f
	} else {
		m.addscore = &f
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *DomainAnnotationToTranscriptMutation) AddedScore() (r float64, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *DomainAnnotationToTranscriptMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetDomainID sets the "domain" edge to the DomainAnnotation entity by id.
func (m *DomainAnnotationToTranscriptMutation) SetDomainID(id string) {
	m.domain = &id
}

// ClearDomain clears the "domain" edge to the DomainAnnotation entity.
func (m *DomainAnnotationToTranscriptMutation) ClearDomain() {
	m.cleareddomain = true
}

// DomainCleared reports if the "domain" edge to the DomainAnnotation entity was cleared.
func (m *DomainAnnotationToTranscriptMutation) DomainCleared() bool {
	return m.cleareddomain
}

// DomainID returns the "domain" edge ID in the mutation.
func (m *DomainAnnotationToTranscriptMutation) DomainID() (id string, exists bool) {
	if m.domain != nil {
		return *m.domain, true
	}
	return
}

// DomainIDs returns the "domain" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DomainID instead. It exists only for internal usage by the builders.
func (m *DomainAnnotationToTranscriptMutation) DomainIDs() (ids []string) {
	if id := m.domain; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDomain resets all changes to the "domain" edge.
func (m *DomainAnnotationToTranscriptMutation) ResetDomain() {
	m.domain = nil
	m.cleareddomain = false
}

// ClearTranscript clears the "transcript" edge to the Transcript entity.
func (m *DomainAnnotationToTranscriptMutation) ClearTranscript() {
	m.clearedtranscript = true
}

// TranscriptCleared reports if the "transcript" edge to the Transcript entity was cleared.
func (m *DomainAnnotationToTranscriptMutation) TranscriptCleared() bool {
	return m.clearedtranscript
}

// TranscriptIDs returns the "transcript" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TranscriptID instead. It exists only for internal usage by the builders.
func (m *DomainAnnotationToTranscriptMutation) TranscriptIDs() (ids []string) {
	if id := m.transcript; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTranscript resets all changes to the "transcript" edge.
func (m *DomainAnnotationToTranscriptMutation) ResetTranscript() {
	m.transcript = nil
	m.clearedtranscript = false
}

// Where appends a list predicates to the DomainAnnotationToTranscriptMutation builder.
func (m *DomainAnnotationToTranscriptMutation) Where(ps ...predicate.DomainAnnotationToTranscript) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DomainAnnotationToTranscriptMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DomainAnnotationToTranscript).
func (m *DomainAnnotationToTranscriptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DomainAnnotationToTranscriptMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.domain != nil {
		fields = append(fields, domainannotationtotranscript.FieldDomainAnnotationID)
	}
	if m.transcript != nil {
		fields = append(fields, domainannotationtotranscript.FieldTranscriptID)
	}
	if m.start != nil {
		fields = append(fields, domainannotationtotranscript.FieldStart)
	}
	if m.stop != nil {
		fields = append(fields, domainannotationtotranscript.FieldStop)
	}
	if m.score != nil {
		fields = append(fields, domainannotationtotranscript.FieldScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DomainAnnotationToTranscriptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case domainannotationtotranscript.FieldDomainAnnotationID:
		return m.DomainAnnotationID()
	case domainannotationtotranscript.FieldTranscriptID:
		return m.TranscriptID()
	case domainannotationtotranscript.FieldStart:
		return m.Start()
	case domainannotationtotranscript.FieldStop:
		return m.Stop()
	case domainannotationtotranscript.FieldScore:
		return m.Score()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DomainAnnotationToTranscriptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema DomainAnnotationToTranscript does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainAnnotationToTranscriptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case domainannotationtotranscript.FieldDomainAnnotationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomainAnnotationID(v)
		return nil
	case domainannotationtotranscript.FieldTranscriptID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTranscriptID(v)
		return nil
	case domainannotationtotranscript.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case domainannotationtotranscript.FieldStop:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStop(v)
		return nil
	case domainannotationtotranscript.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	}
	return fmt.Errorf("unknown DomainAnnotationToTranscript field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DomainAnnotationToTranscriptMutation) AddedFields() []string {
	var fields []string
	if m.addstart != nil {
		fields = append(fields, domainannotationtotranscript.FieldStart)
	}
	if m.addstop != nil {
		fields = append(fields, domainannotationtotranscript.FieldStop)
	}
	if m.addscore != nil {
		fields = append(fields, domainannotationtotranscript.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DomainAnnotationToTranscriptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case domainannotationtotranscript.FieldStart:
		return m.AddedStart()
	case domainannotationtotranscript.FieldStop:
		return m.AddedStop()
	case domainannotationtotranscript.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DomainAnnotationToTranscriptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case domainannotationtotranscript.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case domainannotationtotranscript.FieldStop:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStop(v)
		return nil
	case domainannotationtotranscript.FieldScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown DomainAnnotationToTranscript numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DomainAnnotationToTranscriptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DomainAnnotationToTranscriptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DomainAnnotationToTranscriptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DomainAnnotationToTranscript nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DomainAnnotationToTranscriptMutation) ResetField(name string) error {
	switch name {
	case domainannotationtotranscript.FieldDomainAnnotationID:
		m.ResetDomainAnnotationID()
		return nil
	case domainannotationtotranscript.FieldTranscriptID:
		m.ResetTranscriptID()
		return nil
	case domainannotationtotranscript.FieldStart:
		m.ResetStart()
		return nil
	case domainannotationtotranscript.FieldStop:
		m.ResetStop()
		return nil
	case domainannotationtotranscript.FieldScore:
		m.ResetScore()
		return nil
	}
	return fmt.Errorf("unknown DomainAnnotationToTranscript field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DomainAnnotationToTranscriptMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.domain != nil {
		edges = append(edges, domainannotationtotranscript.EdgeDomain)
	}
	if m.transcript != nil {
		edges = append(edges, domainannotationtotranscript.EdgeTranscript)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DomainAnnotationToTranscriptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case domainannotationtotranscript.EdgeDomain:
		if id := m.domain; id != nil {
			return []ent.Value{*id}
		}
	case domainannotationtotranscript.EdgeTranscript:
		if id := m.transcript; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DomainAnnotationToTranscriptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DomainAnnotationToTranscriptMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DomainAnnotationToTranscriptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddomain {
		edges = append(edges, domainannotationtotranscript.EdgeDomain)
	}
	if m.clearedtranscript {
		edges = append(edges, domainannotationtotranscript.EdgeTranscript)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DomainAnnotationToTranscriptMutation) EdgeCleared(name string) bool {
	switch name {
	case domainannotationtotranscript.EdgeDomain:
		return m.cleareddomain
	case domainannotationtotranscript.EdgeTranscript:
		return m.clearedtranscript
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DomainAnnotationToTranscriptMutation) ClearEdge(name string) error {
	switch name {
	case domainannotationtotranscript.EdgeDomain:
		m.ClearDomain()
		return nil
	case domainannotationtotranscript.EdgeTranscript:
		m.ClearTranscript()
		return nil
	}
	return fmt.Errorf("unknown DomainAnnotationToTranscript unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DomainAnnotationToTranscriptMutation) ResetEdge(name string) error {
	switch name {
	case domainannotationtotranscript.EdgeDomain:
		m.ResetDomain()
		return nil
	case domainannotationtotranscript.EdgeTranscript:
		m.ResetTranscript()
		return nil
	}
	return fmt.Errorf("unknown DomainAnnotationToTranscript edge %s", name)
}

// GenomeMutation represents an operation that mutates the Genome nodes in the graph.
type GenomeMutation struct {
	config
	op               Op
	typ              string
	id               *string
	codon_table      *int32
	addcodon_table   *int32
	clearedFields    map[string]struct{}
	locuses          map[string]struct{}
	removedlocuses   map[string]struct{}
	clearedlocuses   bool
	scaffolds        map[int]struct{}
	removedscaffolds map[int]struct{}
	clearedscaffolds bool
	done             bool
	oldValue         func(context.Context) (*Genome, error)
	predicates       []predicate.Genome
}

var _ ent.Mutation = (*GenomeMutation)(nil)

// genomeOption allows management of the mutation configuration using functional options.
type genomeOption func(*GenomeMutation)

// newGenomeMutation creates new mutation for the Genome entity.
func newGenomeMutation(c config, op Op, opts ...genomeOption) *GenomeMutation {
	m := &GenomeMutation{
		config:        c,
		op:            op,
		typ:           TypeGenome,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenomeID sets the ID field of the mutation.
func withGenomeID(id string) genomeOption {
	return func(m *GenomeMutation) {
		var (
			err   error
			once  sync.Once
			value *Genome
		)
		m.oldValue = func(ctx context.Context) (*Genome, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Genome.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGenome sets the old Genome of the mutation.
func withGenome(node *Genome) genomeOption {
	return func(m *GenomeMutation) {
		m.oldValue = func(context.Context) (*Genome, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenomeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenomeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Genome entities.
func (m *GenomeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GenomeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GenomeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Genome.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCodonTable sets the "codon_table" field.
func (m *GenomeMutation) SetCodonTable(i int32) {
	m.codon_table = &i
	m.addcodon_table = nil
}

// CodonTable returns the value of the "codon_table" field in the mutation.
func (m *GenomeMutation) CodonTable() (r int32, exists bool) {
	v := m.codon_table
	if v == nil {
		return
	}
	return *v, true
}

// OldCodonTable returns the old "codon_table" field's value of the Genome entity.
// If the Genome object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenomeMutation) OldCodonTable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodonTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodonTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodonTable: %w", err)
	}
	return oldValue.CodonTable, nil
}

// AddCodonTable adds i to the "codon_table" field.
func (m *GenomeMutation) AddCodonTable(i int32) {
	if m.addcodon_table != nil {
		*m.addcodon_table += i
	} else {
		m.addcodon_table = &i
	}
}

// AddedCodonTable returns the value that was added to the "codon_table" field in this mutation.
func (m *GenomeMutation) AddedCodonTable() (r int32, exists bool) {
	v := m.addcodon_table
	if v == nil {
		return
	}
	return *v, true
}

// ResetCodonTable resets all changes to the "codon_table" field.
func (m *GenomeMutation) ResetCodonTable() {
	m.codon_table = nil
	m.addcodon_table = nil
}

// AddLocuseIDs adds the "locuses" edge to the Locus entity by ids.
func (m *GenomeMutation) AddLocuseIDs(ids ...string) {
	if m.locuses == nil {
		m.locuses = make(map[string]struct{})
	}
	for i := range ids {
		m.locuses[ids[i]] = struct{}{}
	}
}

// ClearLocuses clears the "locuses" edge to the Locus entity.
func (m *GenomeMutation) ClearLocuses() {
	m.clearedlocuses = true
}

// LocusesCleared reports if the "locuses" edge to the Locus entity was cleared.
func (m *GenomeMutation) LocusesCleared() bool {
	return m.clearedlocuses
}

// RemoveLocuseIDs removes the "locuses" edge to the Locus entity by IDs.
func (m *GenomeMutation) RemoveLocuseIDs(ids ...string) {
	if m.removedlocuses == nil {
		m.removedlocuses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.locuses, ids[i])
		m.removedlocuses[ids[i]] = struct{}{}
	}
}

// RemovedLocuses returns the removed IDs of the "locuses" edge to the Locus entity.
func (m *GenomeMutation) RemovedLocusesIDs() (ids []string) {
	for id := range m.removedlocuses {
		ids = append(ids, id)
	}
	return
}

// LocusesIDs returns the "locuses" edge IDs in the mutation.
func (m *GenomeMutation) LocusesIDs() (ids []string) {
	for id := range m.locuses {
		ids = append(ids, id)
	}
	return
}

// ResetLocuses resets all changes to the "locuses" edge.
func (m *GenomeMutation) ResetLocuses() {
	m.locuses = nil
	m.clearedlocuses = false
	m.removedlocuses = nil
}

// AddScaffoldIDs adds the "scaffolds" edge to the Scaffold entity by ids.
func (m *GenomeMutation) AddScaffoldIDs(ids ...int) {
	if m.scaffolds == nil {
		m.scaffolds = make(map[int]struct{})
	}
	for i := range ids {
		m.scaffolds[ids[i]] = struct{}{}
	}
}

// ClearScaffolds clears the "scaffolds" edge to the Scaffold entity.
func (m *GenomeMutation) ClearScaffolds() {
	m.clearedscaffolds = true
}

// ScaffoldsCleared reports if the "scaffolds" edge to the Scaffold entity was cleared.
func (m *GenomeMutation) ScaffoldsCleared() bool {
	return m.clearedscaffolds
}

// RemoveScaffoldIDs removes the "scaffolds" edge to the Scaffold entity by IDs.
func (m *GenomeMutation) RemoveScaffoldIDs(ids ...int) {
	if m.removedscaffolds == nil {
		m.removedscaffolds = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.scaffolds, ids[i])
		m.removedscaffolds[ids[i]] = struct{}{}
	}
}

// RemovedScaffolds returns the removed IDs of the "scaffolds" edge to the Scaffold entity.
func (m *GenomeMutation) RemovedScaffoldsIDs() (ids []int) {
	for id := range m.removedscaffolds {
		ids = append(ids, id)
	}
	return
}

// ScaffoldsIDs returns the "scaffolds" edge IDs in the mutation.
func (m *GenomeMutation) ScaffoldsIDs() (ids []int) {
	for id := range m.scaffolds {
		ids = append(ids, id)
	}
	return
}

// ResetScaffolds resets all changes to the "scaffolds" edge.
func (m *GenomeMutation) ResetScaffolds() {
	m.scaffolds = nil
	m.clearedscaffolds = false
	m.removedscaffolds = nil
}

// Where appends a list predicates to the GenomeMutation builder.
func (m *GenomeMutation) Where(ps ...predicate.Genome) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GenomeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Genome).
func (m *GenomeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenomeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.codon_table != nil {
		fields = append(fields, genome.FieldCodonTable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenomeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case genome.FieldCodonTable:
		return m.CodonTable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenomeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case genome.FieldCodonTable:
		return m.OldCodonTable(ctx)
	}
	return nil, fmt.Errorf("unknown Genome field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenomeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case genome.FieldCodonTable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodonTable(v)
		return nil
	}
	return fmt.Errorf("unknown Genome field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenomeMutation) AddedFields() []string {
	var fields []string
	if m.addcodon_table != nil {
		fields = append(fields, genome.FieldCodonTable)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenomeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case genome.FieldCodonTable:
		return m.AddedCodonTable()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenomeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case genome.FieldCodonTable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCodonTable(v)
		return nil
	}
	return fmt.Errorf("unknown Genome numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenomeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenomeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenomeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Genome nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenomeMutation) ResetField(name string) error {
	switch name {
	case genome.FieldCodonTable:
		m.ResetCodonTable()
		return nil
	}
	return fmt.Errorf("unknown Genome field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenomeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.locuses != nil {
		edges = append(edges, genome.EdgeLocuses)
	}
	if m.scaffolds != nil {
		edges = append(edges, genome.EdgeScaffolds)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenomeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case genome.EdgeLocuses:
		ids := make([]ent.Value, 0, len(m.locuses))
		for id := range m.locuses {
			ids = append(ids, id)
		}
		return ids
	case genome.EdgeScaffolds:
		ids := make([]ent.Value, 0, len(m.scaffolds))
		for id := range m.scaffolds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenomeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedlocuses != nil {
		edges = append(edges, genome.EdgeLocuses)
	}
	if m.removedscaffolds != nil {
		edges = append(edges, genome.EdgeScaffolds)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenomeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case genome.EdgeLocuses:
		ids := make([]ent.Value, 0, len(m.removedlocuses))
		for id := range m.removedlocuses {
			ids = append(ids, id)
		}
		return ids
	case genome.EdgeScaffolds:
		ids := make([]ent.Value, 0, len(m.removedscaffolds))
		for id := range m.removedscaffolds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenomeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlocuses {
		edges = append(edges, genome.EdgeLocuses)
	}
	if m.clearedscaffolds {
		edges = append(edges, genome.EdgeScaffolds)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenomeMutation) EdgeCleared(name string) bool {
	switch name {
	case genome.EdgeLocuses:
		return m.clearedlocuses
	case genome.EdgeScaffolds:
		return m.clearedscaffolds
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenomeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Genome unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenomeMutation) ResetEdge(name string) error {
	switch name {
	case genome.EdgeLocuses:
		m.ResetLocuses()
		return nil
	case genome.EdgeScaffolds:
		m.ResetScaffolds()
		return nil
	}
	return fmt.Errorf("unknown Genome edge %s", name)
}

// GoTermMutation represents an operation that mutates the GoTerm nodes in the graph.
type GoTermMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	namespace          *goterm.Namespace
	name               *string
	level              *int32
	addlevel           *int32
	depth              *int32
	adddepth           *int32
	clearedFields      map[string]struct{}
	parent             *string
	clearedparent      bool
	children           map[string]struct{}
	removedchildren    map[string]struct{}
	clearedchildren    bool
	transcripts        map[string]struct{}
	removedtranscripts map[string]struct{}
	clearedtranscripts bool
	done               bool
	oldValue           func(context.Context) (*GoTerm, error)
	predicates         []predicate.GoTerm
}

var _ ent.Mutation = (*GoTermMutation)(nil)

// gotermOption allows management of the mutation configuration using functional options.
type gotermOption func(*GoTermMutation)

// newGoTermMutation creates new mutation for the GoTerm entity.
func newGoTermMutation(c config, op Op, opts ...gotermOption) *GoTermMutation {
	m := &GoTermMutation{
		config:        c,
		op:            op,
		typ:           TypeGoTerm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoTermID sets the ID field of the mutation.
func withGoTermID(id string) gotermOption {
	return func(m *GoTermMutation) {
		var (
			err   error
			once  sync.Once
			value *GoTerm
		)
		m.oldValue = func(ctx context.Context) (*GoTerm, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoTerm.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoTerm sets the old GoTerm of the mutation.
func withGoTerm(node *GoTerm) gotermOption {
	return func(m *GoTermMutation) {
		m.oldValue = func(context.Context) (*GoTerm, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoTermMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoTermMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoTerm entities.
func (m *GoTermMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoTermMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoTermMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoTerm.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNamespace sets the "namespace" field.
func (m *GoTermMutation) SetNamespace(_go goterm.Namespace) {
	m.namespace = &_go
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *GoTermMutation) Namespace() (r goterm.Namespace, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the GoTerm entity.
// If the GoTerm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoTermMutation) OldNamespace(ctx context.Context) (v goterm.Namespace, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *GoTermMutation) ResetNamespace() {
	m.namespace = nil
}

// SetName sets the "name" field.
func (m *GoTermMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GoTermMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GoTerm entity.
// If the GoTerm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoTermMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GoTermMutation) ResetName() {
	m.name = nil
}

// SetLevel sets the "level" field.
func (m *GoTermMutation) SetLevel(i int32) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *GoTermMutation) Level() (r int32, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the GoTerm entity.
// If the GoTerm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoTermMutation) OldLevel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *GoTermMutation) AddLevel(i int32) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *GoTermMutation) AddedLevel() (r int32, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *GoTermMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetDepth sets the "depth" field.
func (m *GoTermMutation) SetDepth(i int32) {
	m.depth = &i
	m.adddepth = nil
}

// Depth returns the value of the "depth" field in the mutation.
func (m *GoTermMutation) Depth() (r int32, exists bool) {
	v := m.depth
	if v == nil {
		return
	}
	return *v, true
}

// OldDepth returns the old "depth" field's value of the GoTerm entity.
// If the GoTerm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoTermMutation) OldDepth(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepth: %w", err)
	}
	return oldValue.Depth, nil
}

// AddDepth adds i to the "depth" field.
func (m *GoTermMutation) AddDepth(i int32) {
	if m.adddepth != nil {
		*m.adddepth += i
	} else {
		m.adddepth = &i
	}
}

// AddedDepth returns the value that was added to the "depth" field in this mutation.
func (m *GoTermMutation) AddedDepth() (r int32, exists bool) {
	v := m.adddepth
	if v == nil {
		return
	}
	return *v, true
}

// ResetDepth resets all changes to the "depth" field.
func (m *GoTermMutation) ResetDepth() {
	m.depth = nil
	m.adddepth = nil
}

// SetParentID sets the "parent" edge to the GoTerm entity by id.
func (m *GoTermMutation) SetParentID(id string) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the GoTerm entity.
func (m *GoTermMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the GoTerm entity was cleared.
func (m *GoTermMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *GoTermMutation) ParentID() (id string, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *GoTermMutation) ParentIDs() (ids []string) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *GoTermMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the GoTerm entity by ids.
func (m *GoTermMutation) AddChildIDs(ids ...string) {
	if m.children == nil {
		m.children = make(map[string]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the GoTerm entity.
func (m *GoTermMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the GoTerm entity was cleared.
func (m *GoTermMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the GoTerm entity by IDs.
func (m *GoTermMutation) RemoveChildIDs(ids ...string) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the GoTerm entity.
func (m *GoTermMutation) RemovedChildrenIDs() (ids []string) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *GoTermMutation) ChildrenIDs() (ids []string) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *GoTermMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddTranscriptIDs adds the "transcripts" edge to the Transcript entity by ids.
func (m *GoTermMutation) AddTranscriptIDs(ids ...string) {
	if m.transcripts == nil {
		m.transcripts = make(map[string]struct{})
	}
	for i := range ids {
		m.transcripts[ids[i]] = struct{}{}
	}
}

// ClearTranscripts clears the "transcripts" edge to the Transcript entity.
func (m *GoTermMutation) ClearTranscripts() {
	m.clearedtranscripts = true
}

// TranscriptsCleared reports if the "transcripts" edge to the Transcript entity was cleared.
func (m *GoTermMutation) TranscriptsCleared() bool {
	return m.clearedtranscripts
}

// RemoveTranscriptIDs removes the "transcripts" edge to the Transcript entity by IDs.
func (m *GoTermMutation) RemoveTranscriptIDs(ids ...string) {
	if m.removedtranscripts == nil {
		m.removedtranscripts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transcripts, ids[i])
		m.removedtranscripts[ids[i]] = struct{}{}
	}
}

// RemovedTranscripts returns the removed IDs of the "transcripts" edge to the Transcript entity.
func (m *GoTermMutation) RemovedTranscriptsIDs() (ids []string) {
	for id := range m.removedtranscripts {
		ids = append(ids, id)
	}
	return
}

// TranscriptsIDs returns the "transcripts" edge IDs in the mutation.
func (m *GoTermMutation) TranscriptsIDs() (ids []string) {
	for id := range m.transcripts {
		ids = append(ids, id)
	}
	return
}

// ResetTranscripts resets all changes to the "transcripts" edge.
func (m *GoTermMutation) ResetTranscripts() {
	m.transcripts = nil
	m.clearedtranscripts = false
	m.removedtranscripts = nil
}

// Where appends a list predicates to the GoTermMutation builder.
func (m *GoTermMutation) Where(ps ...predicate.GoTerm) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoTermMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoTerm).
func (m *GoTermMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoTermMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.namespace != nil {
		fields = append(fields, goterm.FieldNamespace)
	}
	if m.name != nil {
		fields = append(fields, goterm.FieldName)
	}
	if m.level != nil {
		fields = append(fields, goterm.FieldLevel)
	}
	if m.depth != nil {
		fields = append(fields, goterm.FieldDepth)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoTermMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goterm.FieldNamespace:
		return m.Namespace()
	case goterm.FieldName:
		return m.Name()
	case goterm.FieldLevel:
		return m.Level()
	case goterm.FieldDepth:
		return m.Depth()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoTermMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goterm.FieldNamespace:
		return m.OldNamespace(ctx)
	case goterm.FieldName:
		return m.OldName(ctx)
	case goterm.FieldLevel:
		return m.OldLevel(ctx)
	case goterm.FieldDepth:
		return m.OldDepth(ctx)
	}
	return nil, fmt.Errorf("unknown GoTerm field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoTermMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goterm.FieldNamespace:
		v, ok := value.(goterm.Namespace)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case goterm.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case goterm.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case goterm.FieldDepth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepth(v)
		return nil
	}
	return fmt.Errorf("unknown GoTerm field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoTermMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, goterm.FieldLevel)
	}
	if m.adddepth != nil {
		fields = append(fields, goterm.FieldDepth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoTermMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goterm.FieldLevel:
		return m.AddedLevel()
	case goterm.FieldDepth:
		return m.AddedDepth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoTermMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goterm.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case goterm.FieldDepth:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepth(v)
		return nil
	}
	return fmt.Errorf("unknown GoTerm numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoTermMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoTermMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoTermMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GoTerm nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoTermMutation) ResetField(name string) error {
	switch name {
	case goterm.FieldNamespace:
		m.ResetNamespace()
		return nil
	case goterm.FieldName:
		m.ResetName()
		return nil
	case goterm.FieldLevel:
		m.ResetLevel()
		return nil
	case goterm.FieldDepth:
		m.ResetDepth()
		return nil
	}
	return fmt.Errorf("unknown GoTerm field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoTermMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, goterm.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, goterm.EdgeChildren)
	}
	if m.transcripts != nil {
		edges = append(edges, goterm.EdgeTranscripts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoTermMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case goterm.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case goterm.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case goterm.EdgeTranscripts:
		ids := make([]ent.Value, 0, len(m.transcripts))
		for id := range m.transcripts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoTermMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, goterm.EdgeChildren)
	}
	if m.removedtranscripts != nil {
		edges = append(edges, goterm.EdgeTranscripts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoTermMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case goterm.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case goterm.EdgeTranscripts:
		ids := make([]ent.Value, 0, len(m.removedtranscripts))
		for id := range m.removedtranscripts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoTermMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, goterm.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, goterm.EdgeChildren)
	}
	if m.clearedtranscripts {
		edges = append(edges, goterm.EdgeTranscripts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoTermMutation) EdgeCleared(name string) bool {
	switch name {
	case goterm.EdgeParent:
		return m.clearedparent
	case goterm.EdgeChildren:
		return m.clearedchildren
	case goterm.EdgeTranscripts:
		return m.clearedtranscripts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoTermMutation) ClearEdge(name string) error {
	switch name {
	case goterm.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown GoTerm unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoTermMutation) ResetEdge(name string) error {
	switch name {
	case goterm.EdgeParent:
		m.ResetParent()
		return nil
	case goterm.EdgeChildren:
		m.ResetChildren()
		return nil
	case goterm.EdgeTranscripts:
		m.ResetTranscripts()
		return nil
	}
	return fmt.Errorf("unknown GoTerm edge %s", name)
}

// GoTermOnTranscriptsMutation represents an operation that mutates the GoTermOnTranscripts nodes in the graph.
type GoTermOnTranscriptsMutation struct {
	config
	op                Op
	typ               string
	evidence_code     *string
	clearedFields     map[string]struct{}
	go_term           *string
	clearedgo_term    bool
	transcript        *string
	clearedtranscript bool
	done              bool
	oldValue          func(context.Context) (*GoTermOnTranscripts, error)
	predicates        []predicate.GoTermOnTranscripts
}

var _ ent.Mutation = (*GoTermOnTranscriptsMutation)(nil)

// gotermontranscriptsOption allows management of the mutation configuration using functional options.
type gotermontranscriptsOption func(*GoTermOnTranscriptsMutation)

// newGoTermOnTranscriptsMutation creates new mutation for the GoTermOnTranscripts entity.
func newGoTermOnTranscriptsMutation(c config, op Op, opts ...gotermontranscriptsOption) *GoTermOnTranscriptsMutation {
	m := &GoTermOnTranscriptsMutation{
		config:        c,
		op:            op,
		typ:           TypeGoTermOnTranscripts,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoTermOnTranscriptsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoTermOnTranscriptsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetEvidenceCode sets the "evidence_code" field.
func (m *GoTermOnTranscriptsMutation) SetEvidenceCode(s string) {
	m.evidence_code = &s
}

// EvidenceCode returns the value of the "evidence_code" field in the mutation.
func (m *GoTermOnTranscriptsMutation) EvidenceCode() (r string, exists bool) {
	v := m.evidence_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetEvidenceCode resets all changes to the "evidence_code" field.
func (m *GoTermOnTranscriptsMutation) ResetEvidenceCode() {
	m.evidence_code = nil
}

// SetGoTermID sets the "go_term_id" field.
func (m *GoTermOnTranscriptsMutation) SetGoTermID(s string) {
	m.go_term = &s
}

// GoTermID returns the value of the "go_term_id" field in the mutation.
func (m *GoTermOnTranscriptsMutation) GoTermID() (r string, exists bool) {
	v := m.go_term
	if v == nil {
		return
	}
	return *v, true
}

// ResetGoTermID resets all changes to the "go_term_id" field.
func (m *GoTermOnTranscriptsMutation) ResetGoTermID() {
	m.go_term = nil
}

// SetTranscriptID sets the "transcript_id" field.
func (m *GoTermOnTranscriptsMutation) SetTranscriptID(s string) {
	m.transcript = &s
}

// TranscriptID returns the value of the "transcript_id" field in the mutation.
func (m *GoTermOnTranscriptsMutation) TranscriptID() (r string, exists bool) {
	v := m.transcript
	if v == nil {
		return
	}
	return *v, true
}

// ResetTranscriptID resets all changes to the "transcript_id" field.
func (m *GoTermOnTranscriptsMutation) ResetTranscriptID() {
	m.transcript = nil
}

// ClearGoTerm clears the "go_term" edge to the GoTerm entity.
func (m *GoTermOnTranscriptsMutation) ClearGoTerm() {
	m.clearedgo_term = true
}

// GoTermCleared reports if the "go_term" edge to the GoTerm entity was cleared.
func (m *GoTermOnTranscriptsMutation) GoTermCleared() bool {
	return m.clearedgo_term
}

// GoTermIDs returns the "go_term" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GoTermID instead. It exists only for internal usage by the builders.
func (m *GoTermOnTranscriptsMutation) GoTermIDs() (ids []string) {
	if id := m.go_term; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGoTerm resets all changes to the "go_term" edge.
func (m *GoTermOnTranscriptsMutation) ResetGoTerm() {
	m.go_term = nil
	m.clearedgo_term = false
}

// ClearTranscript clears the "transcript" edge to the Transcript entity.
func (m *GoTermOnTranscriptsMutation) ClearTranscript() {
	m.clearedtranscript = true
}

// TranscriptCleared reports if the "transcript" edge to the Transcript entity was cleared.
func (m *GoTermOnTranscriptsMutation) TranscriptCleared() bool {
	return m.clearedtranscript
}

// TranscriptIDs returns the "transcript" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TranscriptID instead. It exists only for internal usage by the builders.
func (m *GoTermOnTranscriptsMutation) TranscriptIDs() (ids []string) {
	if id := m.transcript; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTranscript resets all changes to the "transcript" edge.
func (m *GoTermOnTranscriptsMutation) ResetTranscript() {
	m.transcript = nil
	m.clearedtranscript = false
}

// Where appends a list predicates to the GoTermOnTranscriptsMutation builder.
func (m *GoTermOnTranscriptsMutation) Where(ps ...predicate.GoTermOnTranscripts) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoTermOnTranscriptsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoTermOnTranscripts).
func (m *GoTermOnTranscriptsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoTermOnTranscriptsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.evidence_code != nil {
		fields = append(fields, gotermontranscripts.FieldEvidenceCode)
	}
	if m.go_term != nil {
		fields = append(fields, gotermontranscripts.FieldGoTermID)
	}
	if m.transcript != nil {
		fields = append(fields, gotermontranscripts.FieldTranscriptID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoTermOnTranscriptsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gotermontranscripts.FieldEvidenceCode:
		return m.EvidenceCode()
	case gotermontranscripts.FieldGoTermID:
		return m.GoTermID()
	case gotermontranscripts.FieldTranscriptID:
		return m.TranscriptID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoTermOnTranscriptsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema GoTermOnTranscripts does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoTermOnTranscriptsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gotermontranscripts.FieldEvidenceCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvidenceCode(v)
		return nil
	case gotermontranscripts.FieldGoTermID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoTermID(v)
		return nil
	case gotermontranscripts.FieldTranscriptID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTranscriptID(v)
		return nil
	}
	return fmt.Errorf("unknown GoTermOnTranscripts field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoTermOnTranscriptsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoTermOnTranscriptsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoTermOnTranscriptsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GoTermOnTranscripts numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoTermOnTranscriptsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoTermOnTranscriptsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoTermOnTranscriptsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GoTermOnTranscripts nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoTermOnTranscriptsMutation) ResetField(name string) error {
	switch name {
	case gotermontranscripts.FieldEvidenceCode:
		m.ResetEvidenceCode()
		return nil
	case gotermontranscripts.FieldGoTermID:
		m.ResetGoTermID()
		return nil
	case gotermontranscripts.FieldTranscriptID:
		m.ResetTranscriptID()
		return nil
	}
	return fmt.Errorf("unknown GoTermOnTranscripts field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoTermOnTranscriptsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.go_term != nil {
		edges = append(edges, gotermontranscripts.EdgeGoTerm)
	}
	if m.transcript != nil {
		edges = append(edges, gotermontranscripts.EdgeTranscript)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoTermOnTranscriptsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gotermontranscripts.EdgeGoTerm:
		if id := m.go_term; id != nil {
			return []ent.Value{*id}
		}
	case gotermontranscripts.EdgeTranscript:
		if id := m.transcript; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoTermOnTranscriptsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoTermOnTranscriptsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoTermOnTranscriptsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgo_term {
		edges = append(edges, gotermontranscripts.EdgeGoTerm)
	}
	if m.clearedtranscript {
		edges = append(edges, gotermontranscripts.EdgeTranscript)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoTermOnTranscriptsMutation) EdgeCleared(name string) bool {
	switch name {
	case gotermontranscripts.EdgeGoTerm:
		return m.clearedgo_term
	case gotermontranscripts.EdgeTranscript:
		return m.clearedtranscript
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoTermOnTranscriptsMutation) ClearEdge(name string) error {
	switch name {
	case gotermontranscripts.EdgeGoTerm:
		m.ClearGoTerm()
		return nil
	case gotermontranscripts.EdgeTranscript:
		m.ClearTranscript()
		return nil
	}
	return fmt.Errorf("unknown GoTermOnTranscripts unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoTermOnTranscriptsMutation) ResetEdge(name string) error {
	switch name {
	case gotermontranscripts.EdgeGoTerm:
		m.ResetGoTerm()
		return nil
	case gotermontranscripts.EdgeTranscript:
		m.ResetTranscript()
		return nil
	}
	return fmt.Errorf("unknown GoTermOnTranscripts edge %s", name)
}

// KeggCompoundMutation represents an operation that mutates the KeggCompound nodes in the graph.
type KeggCompoundMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*KeggCompound, error)
	predicates    []predicate.KeggCompound
}

var _ ent.Mutation = (*KeggCompoundMutation)(nil)

// keggcompoundOption allows management of the mutation configuration using functional options.
type keggcompoundOption func(*KeggCompoundMutation)

// newKeggCompoundMutation creates new mutation for the KeggCompound entity.
func newKeggCompoundMutation(c config, op Op, opts ...keggcompoundOption) *KeggCompoundMutation {
	m := &KeggCompoundMutation{
		config:        c,
		op:            op,
		typ:           TypeKeggCompound,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKeggCompoundID sets the ID field of the mutation.
func withKeggCompoundID(id string) keggcompoundOption {
	return func(m *KeggCompoundMutation) {
		var (
			err   error
			once  sync.Once
			value *KeggCompound
		)
		m.oldValue = func(ctx context.Context) (*KeggCompound, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KeggCompound.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKeggCompound sets the old KeggCompound of the mutation.
func withKeggCompound(node *KeggCompound) keggcompoundOption {
	return func(m *KeggCompoundMutation) {
		m.oldValue = func(context.Context) (*KeggCompound, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KeggCompoundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KeggCompoundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of KeggCompound entities.
func (m *KeggCompoundMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KeggCompoundMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KeggCompoundMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KeggCompound.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the KeggCompoundMutation builder.
func (m *KeggCompoundMutation) Where(ps ...predicate.KeggCompound) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *KeggCompoundMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KeggCompound).
func (m *KeggCompoundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KeggCompoundMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KeggCompoundMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KeggCompoundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown KeggCompound field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeggCompoundMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KeggCompound field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KeggCompoundMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KeggCompoundMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeggCompoundMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown KeggCompound numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KeggCompoundMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KeggCompoundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KeggCompoundMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KeggCompound nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KeggCompoundMutation) ResetField(name string) error {
	return fmt.Errorf("unknown KeggCompound field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KeggCompoundMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KeggCompoundMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KeggCompoundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KeggCompoundMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KeggCompoundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KeggCompoundMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KeggCompoundMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown KeggCompound unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KeggCompoundMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown KeggCompound edge %s", name)
}

// KeggModuleMutation represents an operation that mutates the KeggModule nodes in the graph.
type KeggModuleMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*KeggModule, error)
	predicates    []predicate.KeggModule
}

var _ ent.Mutation = (*KeggModuleMutation)(nil)

// keggmoduleOption allows management of the mutation configuration using functional options.
type keggmoduleOption func(*KeggModuleMutation)

// newKeggModuleMutation creates new mutation for the KeggModule entity.
func newKeggModuleMutation(c config, op Op, opts ...keggmoduleOption) *KeggModuleMutation {
	m := &KeggModuleMutation{
		config:        c,
		op:            op,
		typ:           TypeKeggModule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKeggModuleID sets the ID field of the mutation.
func withKeggModuleID(id string) keggmoduleOption {
	return func(m *KeggModuleMutation) {
		var (
			err   error
			once  sync.Once
			value *KeggModule
		)
		m.oldValue = func(ctx context.Context) (*KeggModule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KeggModule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKeggModule sets the old KeggModule of the mutation.
func withKeggModule(node *KeggModule) keggmoduleOption {
	return func(m *KeggModuleMutation) {
		m.oldValue = func(context.Context) (*KeggModule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KeggModuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KeggModuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of KeggModule entities.
func (m *KeggModuleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KeggModuleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KeggModuleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KeggModule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the KeggModuleMutation builder.
func (m *KeggModuleMutation) Where(ps ...predicate.KeggModule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *KeggModuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KeggModule).
func (m *KeggModuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KeggModuleMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KeggModuleMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KeggModuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown KeggModule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeggModuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KeggModule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KeggModuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KeggModuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeggModuleMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown KeggModule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KeggModuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KeggModuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KeggModuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KeggModule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KeggModuleMutation) ResetField(name string) error {
	return fmt.Errorf("unknown KeggModule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KeggModuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KeggModuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KeggModuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KeggModuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KeggModuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KeggModuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KeggModuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown KeggModule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KeggModuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown KeggModule edge %s", name)
}

// KeggOntologyMutation represents an operation that mutates the KeggOntology nodes in the graph.
type KeggOntologyMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	symbol        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*KeggOntology, error)
	predicates    []predicate.KeggOntology
}

var _ ent.Mutation = (*KeggOntologyMutation)(nil)

// keggontologyOption allows management of the mutation configuration using functional options.
type keggontologyOption func(*KeggOntologyMutation)

// newKeggOntologyMutation creates new mutation for the KeggOntology entity.
func newKeggOntologyMutation(c config, op Op, opts ...keggontologyOption) *KeggOntologyMutation {
	m := &KeggOntologyMutation{
		config:        c,
		op:            op,
		typ:           TypeKeggOntology,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKeggOntologyID sets the ID field of the mutation.
func withKeggOntologyID(id string) keggontologyOption {
	return func(m *KeggOntologyMutation) {
		var (
			err   error
			once  sync.Once
			value *KeggOntology
		)
		m.oldValue = func(ctx context.Context) (*KeggOntology, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KeggOntology.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKeggOntology sets the old KeggOntology of the mutation.
func withKeggOntology(node *KeggOntology) keggontologyOption {
	return func(m *KeggOntologyMutation) {
		m.oldValue = func(context.Context) (*KeggOntology, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KeggOntologyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KeggOntologyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of KeggOntology entities.
func (m *KeggOntologyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KeggOntologyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KeggOntologyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KeggOntology.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *KeggOntologyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *KeggOntologyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the KeggOntology entity.
// If the KeggOntology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeggOntologyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *KeggOntologyMutation) ResetName() {
	m.name = nil
}

// SetSymbol sets the "symbol" field.
func (m *KeggOntologyMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *KeggOntologyMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the KeggOntology entity.
// If the KeggOntology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeggOntologyMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *KeggOntologyMutation) ResetSymbol() {
	m.symbol = nil
}

// Where appends a list predicates to the KeggOntologyMutation builder.
func (m *KeggOntologyMutation) Where(ps ...predicate.KeggOntology) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *KeggOntologyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KeggOntology).
func (m *KeggOntologyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KeggOntologyMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, keggontology.FieldName)
	}
	if m.symbol != nil {
		fields = append(fields, keggontology.FieldSymbol)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KeggOntologyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case keggontology.FieldName:
		return m.Name()
	case keggontology.FieldSymbol:
		return m.Symbol()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KeggOntologyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case keggontology.FieldName:
		return m.OldName(ctx)
	case keggontology.FieldSymbol:
		return m.OldSymbol(ctx)
	}
	return nil, fmt.Errorf("unknown KeggOntology field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeggOntologyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case keggontology.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case keggontology.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	}
	return fmt.Errorf("unknown KeggOntology field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KeggOntologyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KeggOntologyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeggOntologyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KeggOntology numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KeggOntologyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KeggOntologyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KeggOntologyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KeggOntology nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KeggOntologyMutation) ResetField(name string) error {
	switch name {
	case keggontology.FieldName:
		m.ResetName()
		return nil
	case keggontology.FieldSymbol:
		m.ResetSymbol()
		return nil
	}
	return fmt.Errorf("unknown KeggOntology field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KeggOntologyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KeggOntologyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KeggOntologyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KeggOntologyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KeggOntologyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KeggOntologyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KeggOntologyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown KeggOntology unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KeggOntologyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown KeggOntology edge %s", name)
}

// KeggPathwayMutation represents an operation that mutates the KeggPathway nodes in the graph.
type KeggPathwayMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*KeggPathway, error)
	predicates    []predicate.KeggPathway
}

var _ ent.Mutation = (*KeggPathwayMutation)(nil)

// keggpathwayOption allows management of the mutation configuration using functional options.
type keggpathwayOption func(*KeggPathwayMutation)

// newKeggPathwayMutation creates new mutation for the KeggPathway entity.
func newKeggPathwayMutation(c config, op Op, opts ...keggpathwayOption) *KeggPathwayMutation {
	m := &KeggPathwayMutation{
		config:        c,
		op:            op,
		typ:           TypeKeggPathway,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKeggPathwayID sets the ID field of the mutation.
func withKeggPathwayID(id string) keggpathwayOption {
	return func(m *KeggPathwayMutation) {
		var (
			err   error
			once  sync.Once
			value *KeggPathway
		)
		m.oldValue = func(ctx context.Context) (*KeggPathway, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KeggPathway.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKeggPathway sets the old KeggPathway of the mutation.
func withKeggPathway(node *KeggPathway) keggpathwayOption {
	return func(m *KeggPathwayMutation) {
		m.oldValue = func(context.Context) (*KeggPathway, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KeggPathwayMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KeggPathwayMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of KeggPathway entities.
func (m *KeggPathwayMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KeggPathwayMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KeggPathwayMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KeggPathway.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the KeggPathwayMutation builder.
func (m *KeggPathwayMutation) Where(ps ...predicate.KeggPathway) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *KeggPathwayMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KeggPathway).
func (m *KeggPathwayMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KeggPathwayMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KeggPathwayMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KeggPathwayMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown KeggPathway field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeggPathwayMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KeggPathway field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KeggPathwayMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KeggPathwayMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeggPathwayMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown KeggPathway numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KeggPathwayMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KeggPathwayMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KeggPathwayMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KeggPathway nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KeggPathwayMutation) ResetField(name string) error {
	return fmt.Errorf("unknown KeggPathway field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KeggPathwayMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KeggPathwayMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KeggPathwayMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KeggPathwayMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KeggPathwayMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KeggPathwayMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KeggPathwayMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown KeggPathway unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KeggPathwayMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown KeggPathway edge %s", name)
}

// KeggReactionMutation represents an operation that mutates the KeggReaction nodes in the graph.
type KeggReactionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*KeggReaction, error)
	predicates    []predicate.KeggReaction
}

var _ ent.Mutation = (*KeggReactionMutation)(nil)

// keggreactionOption allows management of the mutation configuration using functional options.
type keggreactionOption func(*KeggReactionMutation)

// newKeggReactionMutation creates new mutation for the KeggReaction entity.
func newKeggReactionMutation(c config, op Op, opts ...keggreactionOption) *KeggReactionMutation {
	m := &KeggReactionMutation{
		config:        c,
		op:            op,
		typ:           TypeKeggReaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKeggReactionID sets the ID field of the mutation.
func withKeggReactionID(id int) keggreactionOption {
	return func(m *KeggReactionMutation) {
		var (
			err   error
			once  sync.Once
			value *KeggReaction
		)
		m.oldValue = func(ctx context.Context) (*KeggReaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().KeggReaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKeggReaction sets the old KeggReaction of the mutation.
func withKeggReaction(node *KeggReaction) keggreactionOption {
	return func(m *KeggReactionMutation) {
		m.oldValue = func(context.Context) (*KeggReaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KeggReactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KeggReactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KeggReactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KeggReactionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().KeggReaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the KeggReactionMutation builder.
func (m *KeggReactionMutation) Where(ps ...predicate.KeggReaction) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *KeggReactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (KeggReaction).
func (m *KeggReactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KeggReactionMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KeggReactionMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KeggReactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown KeggReaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeggReactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown KeggReaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KeggReactionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KeggReactionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeggReactionMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown KeggReaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KeggReactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KeggReactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KeggReactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown KeggReaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KeggReactionMutation) ResetField(name string) error {
	return fmt.Errorf("unknown KeggReaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KeggReactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KeggReactionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KeggReactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KeggReactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KeggReactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KeggReactionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KeggReactionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown KeggReaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KeggReactionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown KeggReaction edge %s", name)
}

// LocusMutation represents an operation that mutates the Locus nodes in the graph.
type LocusMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	clearedFields      map[string]struct{}
	transcripts        map[string]struct{}
	removedtranscripts map[string]struct{}
	clearedtranscripts bool
	genome             *string
	clearedgenome      bool
	done               bool
	oldValue           func(context.Context) (*Locus, error)
	predicates         []predicate.Locus
}

var _ ent.Mutation = (*LocusMutation)(nil)

// locusOption allows management of the mutation configuration using functional options.
type locusOption func(*LocusMutation)

// newLocusMutation creates new mutation for the Locus entity.
func newLocusMutation(c config, op Op, opts ...locusOption) *LocusMutation {
	m := &LocusMutation{
		config:        c,
		op:            op,
		typ:           TypeLocus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocusID sets the ID field of the mutation.
func withLocusID(id string) locusOption {
	return func(m *LocusMutation) {
		var (
			err   error
			once  sync.Once
			value *Locus
		)
		m.oldValue = func(ctx context.Context) (*Locus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Locus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocus sets the old Locus of the mutation.
func withLocus(node *Locus) locusOption {
	return func(m *LocusMutation) {
		m.oldValue = func(context.Context) (*Locus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Locus entities.
func (m *LocusMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocusMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocusMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Locus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddTranscriptIDs adds the "transcripts" edge to the Transcript entity by ids.
func (m *LocusMutation) AddTranscriptIDs(ids ...string) {
	if m.transcripts == nil {
		m.transcripts = make(map[string]struct{})
	}
	for i := range ids {
		m.transcripts[ids[i]] = struct{}{}
	}
}

// ClearTranscripts clears the "transcripts" edge to the Transcript entity.
func (m *LocusMutation) ClearTranscripts() {
	m.clearedtranscripts = true
}

// TranscriptsCleared reports if the "transcripts" edge to the Transcript entity was cleared.
func (m *LocusMutation) TranscriptsCleared() bool {
	return m.clearedtranscripts
}

// RemoveTranscriptIDs removes the "transcripts" edge to the Transcript entity by IDs.
func (m *LocusMutation) RemoveTranscriptIDs(ids ...string) {
	if m.removedtranscripts == nil {
		m.removedtranscripts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.transcripts, ids[i])
		m.removedtranscripts[ids[i]] = struct{}{}
	}
}

// RemovedTranscripts returns the removed IDs of the "transcripts" edge to the Transcript entity.
func (m *LocusMutation) RemovedTranscriptsIDs() (ids []string) {
	for id := range m.removedtranscripts {
		ids = append(ids, id)
	}
	return
}

// TranscriptsIDs returns the "transcripts" edge IDs in the mutation.
func (m *LocusMutation) TranscriptsIDs() (ids []string) {
	for id := range m.transcripts {
		ids = append(ids, id)
	}
	return
}

// ResetTranscripts resets all changes to the "transcripts" edge.
func (m *LocusMutation) ResetTranscripts() {
	m.transcripts = nil
	m.clearedtranscripts = false
	m.removedtranscripts = nil
}

// SetGenomeID sets the "genome" edge to the Genome entity by id.
func (m *LocusMutation) SetGenomeID(id string) {
	m.genome = &id
}

// ClearGenome clears the "genome" edge to the Genome entity.
func (m *LocusMutation) ClearGenome() {
	m.clearedgenome = true
}

// GenomeCleared reports if the "genome" edge to the Genome entity was cleared.
func (m *LocusMutation) GenomeCleared() bool {
	return m.clearedgenome
}

// GenomeID returns the "genome" edge ID in the mutation.
func (m *LocusMutation) GenomeID() (id string, exists bool) {
	if m.genome != nil {
		return *m.genome, true
	}
	return
}

// GenomeIDs returns the "genome" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenomeID instead. It exists only for internal usage by the builders.
func (m *LocusMutation) GenomeIDs() (ids []string) {
	if id := m.genome; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenome resets all changes to the "genome" edge.
func (m *LocusMutation) ResetGenome() {
	m.genome = nil
	m.clearedgenome = false
}

// Where appends a list predicates to the LocusMutation builder.
func (m *LocusMutation) Where(ps ...predicate.Locus) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LocusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Locus).
func (m *LocusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocusMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocusMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Locus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocusMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Locus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocusMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Locus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Locus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocusMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Locus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocusMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.transcripts != nil {
		edges = append(edges, locus.EdgeTranscripts)
	}
	if m.genome != nil {
		edges = append(edges, locus.EdgeGenome)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case locus.EdgeTranscripts:
		ids := make([]ent.Value, 0, len(m.transcripts))
		for id := range m.transcripts {
			ids = append(ids, id)
		}
		return ids
	case locus.EdgeGenome:
		if id := m.genome; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtranscripts != nil {
		edges = append(edges, locus.EdgeTranscripts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case locus.EdgeTranscripts:
		ids := make([]ent.Value, 0, len(m.removedtranscripts))
		for id := range m.removedtranscripts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtranscripts {
		edges = append(edges, locus.EdgeTranscripts)
	}
	if m.clearedgenome {
		edges = append(edges, locus.EdgeGenome)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocusMutation) EdgeCleared(name string) bool {
	switch name {
	case locus.EdgeTranscripts:
		return m.clearedtranscripts
	case locus.EdgeGenome:
		return m.clearedgenome
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocusMutation) ClearEdge(name string) error {
	switch name {
	case locus.EdgeGenome:
		m.ClearGenome()
		return nil
	}
	return fmt.Errorf("unknown Locus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocusMutation) ResetEdge(name string) error {
	switch name {
	case locus.EdgeTranscripts:
		m.ResetTranscripts()
		return nil
	case locus.EdgeGenome:
		m.ResetGenome()
		return nil
	}
	return fmt.Errorf("unknown Locus edge %s", name)
}

// ScaffoldMutation represents an operation that mutates the Scaffold nodes in the graph.
type ScaffoldMutation struct {
	config
	op            Op
	typ           string
	id            *int
	seqname       *string
	seq           *string
	clearedFields map[string]struct{}
	genome        *string
	clearedgenome bool
	done          bool
	oldValue      func(context.Context) (*Scaffold, error)
	predicates    []predicate.Scaffold
}

var _ ent.Mutation = (*ScaffoldMutation)(nil)

// scaffoldOption allows management of the mutation configuration using functional options.
type scaffoldOption func(*ScaffoldMutation)

// newScaffoldMutation creates new mutation for the Scaffold entity.
func newScaffoldMutation(c config, op Op, opts ...scaffoldOption) *ScaffoldMutation {
	m := &ScaffoldMutation{
		config:        c,
		op:            op,
		typ:           TypeScaffold,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScaffoldID sets the ID field of the mutation.
func withScaffoldID(id int) scaffoldOption {
	return func(m *ScaffoldMutation) {
		var (
			err   error
			once  sync.Once
			value *Scaffold
		)
		m.oldValue = func(ctx context.Context) (*Scaffold, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Scaffold.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScaffold sets the old Scaffold of the mutation.
func withScaffold(node *Scaffold) scaffoldOption {
	return func(m *ScaffoldMutation) {
		m.oldValue = func(context.Context) (*Scaffold, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScaffoldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScaffoldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScaffoldMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScaffoldMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Scaffold.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeqname sets the "seqname" field.
func (m *ScaffoldMutation) SetSeqname(s string) {
	m.seqname = &s
}

// Seqname returns the value of the "seqname" field in the mutation.
func (m *ScaffoldMutation) Seqname() (r string, exists bool) {
	v := m.seqname
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqname returns the old "seqname" field's value of the Scaffold entity.
// If the Scaffold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScaffoldMutation) OldSeqname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeqname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeqname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqname: %w", err)
	}
	return oldValue.Seqname, nil
}

// ResetSeqname resets all changes to the "seqname" field.
func (m *ScaffoldMutation) ResetSeqname() {
	m.seqname = nil
}

// SetSeq sets the "seq" field.
func (m *ScaffoldMutation) SetSeq(s string) {
	m.seq = &s
}

// Seq returns the value of the "seq" field in the mutation.
func (m *ScaffoldMutation) Seq() (r string, exists bool) {
	v := m.seq
	if v == nil {
		return
	}
	return *v, true
}

// OldSeq returns the old "seq" field's value of the Scaffold entity.
// If the Scaffold object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScaffoldMutation) OldSeq(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeq is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeq requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeq: %w", err)
	}
	return oldValue.Seq, nil
}

// ResetSeq resets all changes to the "seq" field.
func (m *ScaffoldMutation) ResetSeq() {
	m.seq = nil
}

// SetGenomeID sets the "genome" edge to the Genome entity by id.
func (m *ScaffoldMutation) SetGenomeID(id string) {
	m.genome = &id
}

// ClearGenome clears the "genome" edge to the Genome entity.
func (m *ScaffoldMutation) ClearGenome() {
	m.clearedgenome = true
}

// GenomeCleared reports if the "genome" edge to the Genome entity was cleared.
func (m *ScaffoldMutation) GenomeCleared() bool {
	return m.clearedgenome
}

// GenomeID returns the "genome" edge ID in the mutation.
func (m *ScaffoldMutation) GenomeID() (id string, exists bool) {
	if m.genome != nil {
		return *m.genome, true
	}
	return
}

// GenomeIDs returns the "genome" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GenomeID instead. It exists only for internal usage by the builders.
func (m *ScaffoldMutation) GenomeIDs() (ids []string) {
	if id := m.genome; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGenome resets all changes to the "genome" edge.
func (m *ScaffoldMutation) ResetGenome() {
	m.genome = nil
	m.clearedgenome = false
}

// Where appends a list predicates to the ScaffoldMutation builder.
func (m *ScaffoldMutation) Where(ps ...predicate.Scaffold) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ScaffoldMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Scaffold).
func (m *ScaffoldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScaffoldMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.seqname != nil {
		fields = append(fields, scaffold.FieldSeqname)
	}
	if m.seq != nil {
		fields = append(fields, scaffold.FieldSeq)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScaffoldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scaffold.FieldSeqname:
		return m.Seqname()
	case scaffold.FieldSeq:
		return m.Seq()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScaffoldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scaffold.FieldSeqname:
		return m.OldSeqname(ctx)
	case scaffold.FieldSeq:
		return m.OldSeq(ctx)
	}
	return nil, fmt.Errorf("unknown Scaffold field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScaffoldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scaffold.FieldSeqname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqname(v)
		return nil
	case scaffold.FieldSeq:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeq(v)
		return nil
	}
	return fmt.Errorf("unknown Scaffold field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScaffoldMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScaffoldMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScaffoldMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Scaffold numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScaffoldMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScaffoldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScaffoldMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Scaffold nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScaffoldMutation) ResetField(name string) error {
	switch name {
	case scaffold.FieldSeqname:
		m.ResetSeqname()
		return nil
	case scaffold.FieldSeq:
		m.ResetSeq()
		return nil
	}
	return fmt.Errorf("unknown Scaffold field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScaffoldMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.genome != nil {
		edges = append(edges, scaffold.EdgeGenome)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScaffoldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scaffold.EdgeGenome:
		if id := m.genome; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScaffoldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScaffoldMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScaffoldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgenome {
		edges = append(edges, scaffold.EdgeGenome)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScaffoldMutation) EdgeCleared(name string) bool {
	switch name {
	case scaffold.EdgeGenome:
		return m.clearedgenome
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScaffoldMutation) ClearEdge(name string) error {
	switch name {
	case scaffold.EdgeGenome:
		m.ClearGenome()
		return nil
	}
	return fmt.Errorf("unknown Scaffold unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScaffoldMutation) ResetEdge(name string) error {
	switch name {
	case scaffold.EdgeGenome:
		m.ResetGenome()
		return nil
	}
	return fmt.Errorf("unknown Scaffold edge %s", name)
}

// TranscriptMutation represents an operation that mutates the Transcript nodes in the graph.
type TranscriptMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	seqname               *string
	strand                *string
	_type                 *string
	source                *string
	start                 *int32
	addstart              *int32
	end                   *int32
	addend                *int32
	exon                  *[]gffio.GffRecord
	appendexon            []gffio.GffRecord
	five_prime_utr        *[]gffio.GffRecord
	appendfive_prime_utr  []gffio.GffRecord
	three_prime_utr       *[]gffio.GffRecord
	appendthree_prime_utr []gffio.GffRecord
	cds                   *[]gffio.GffRecord
	appendcds             []gffio.GffRecord
	genomic_sequence      *string
	exon_sequence         *string
	cds_sequence          *string
	protein_sequence      *string
	clearedFields         map[string]struct{}
	locus                 *string
	clearedlocus          bool
	goterms               map[string]struct{}
	removedgoterms        map[string]struct{}
	clearedgoterms        bool
	domains               map[string]struct{}
	removeddomains        map[string]struct{}
	cleareddomains        bool
	done                  bool
	oldValue              func(context.Context) (*Transcript, error)
	predicates            []predicate.Transcript
}

var _ ent.Mutation = (*TranscriptMutation)(nil)

// transcriptOption allows management of the mutation configuration using functional options.
type transcriptOption func(*TranscriptMutation)

// newTranscriptMutation creates new mutation for the Transcript entity.
func newTranscriptMutation(c config, op Op, opts ...transcriptOption) *TranscriptMutation {
	m := &TranscriptMutation{
		config:        c,
		op:            op,
		typ:           TypeTranscript,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTranscriptID sets the ID field of the mutation.
func withTranscriptID(id string) transcriptOption {
	return func(m *TranscriptMutation) {
		var (
			err   error
			once  sync.Once
			value *Transcript
		)
		m.oldValue = func(ctx context.Context) (*Transcript, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transcript.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTranscript sets the old Transcript of the mutation.
func withTranscript(node *Transcript) transcriptOption {
	return func(m *TranscriptMutation) {
		m.oldValue = func(context.Context) (*Transcript, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TranscriptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TranscriptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transcript entities.
func (m *TranscriptMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TranscriptMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TranscriptMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transcript.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeqname sets the "seqname" field.
func (m *TranscriptMutation) SetSeqname(s string) {
	m.seqname = &s
}

// Seqname returns the value of the "seqname" field in the mutation.
func (m *TranscriptMutation) Seqname() (r string, exists bool) {
	v := m.seqname
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqname returns the old "seqname" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldSeqname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeqname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeqname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqname: %w", err)
	}
	return oldValue.Seqname, nil
}

// ResetSeqname resets all changes to the "seqname" field.
func (m *TranscriptMutation) ResetSeqname() {
	m.seqname = nil
}

// SetStrand sets the "strand" field.
func (m *TranscriptMutation) SetStrand(s string) {
	m.strand = &s
}

// Strand returns the value of the "strand" field in the mutation.
func (m *TranscriptMutation) Strand() (r string, exists bool) {
	v := m.strand
	if v == nil {
		return
	}
	return *v, true
}

// OldStrand returns the old "strand" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldStrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrand: %w", err)
	}
	return oldValue.Strand, nil
}

// ResetStrand resets all changes to the "strand" field.
func (m *TranscriptMutation) ResetStrand() {
	m.strand = nil
}

// SetType sets the "type" field.
func (m *TranscriptMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TranscriptMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TranscriptMutation) ResetType() {
	m._type = nil
}

// SetSource sets the "source" field.
func (m *TranscriptMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *TranscriptMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TranscriptMutation) ResetSource() {
	m.source = nil
}

// SetStart sets the "start" field.
func (m *TranscriptMutation) SetStart(i int32) {
	m.start = &i
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *TranscriptMutation) Start() (r int32, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldStart(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds i to the "start" field.
func (m *TranscriptMutation) AddStart(i int32) {
	if m.addstart != nil {
		*m.addstart += i
	} else {
		m.addstart = &i
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *TranscriptMutation) AddedStart() (r int32, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *TranscriptMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *TranscriptMutation) SetEnd(i int32) {
	m.end = &i
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *TranscriptMutation) End() (r int32, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldEnd(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds i to the "end" field.
func (m *TranscriptMutation) AddEnd(i int32) {
	if m.addend != nil {
		*m.addend += i
	} else {
		m.addend = &i
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *TranscriptMutation) AddedEnd() (r int32, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *TranscriptMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetExon sets the "exon" field.
func (m *TranscriptMutation) SetExon(gr []gffio.GffRecord) {
	m.exon = &gr
	m.appendexon = nil
}

// Exon returns the value of the "exon" field in the mutation.
func (m *TranscriptMutation) Exon() (r []gffio.GffRecord, exists bool) {
	v := m.exon
	if v == nil {
		return
	}
	return *v, true
}

// OldExon returns the old "exon" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldExon(ctx context.Context) (v []gffio.GffRecord, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExon: %w", err)
	}
	return oldValue.Exon, nil
}

// AppendExon adds gr to the "exon" field.
func (m *TranscriptMutation) AppendExon(gr []gffio.GffRecord) {
	m.appendexon = append(m.appendexon, gr...)
}

// AppendedExon returns the list of values that were appended to the "exon" field in this mutation.
func (m *TranscriptMutation) AppendedExon() ([]gffio.GffRecord, bool) {
	if len(m.appendexon) == 0 {
		return nil, false
	}
	return m.appendexon, true
}

// ResetExon resets all changes to the "exon" field.
func (m *TranscriptMutation) ResetExon() {
	m.exon = nil
	m.appendexon = nil
}

// SetFivePrimeUtr sets the "five_prime_utr" field.
func (m *TranscriptMutation) SetFivePrimeUtr(gr []gffio.GffRecord) {
	m.five_prime_utr = &gr
	m.appendfive_prime_utr = nil
}

// FivePrimeUtr returns the value of the "five_prime_utr" field in the mutation.
func (m *TranscriptMutation) FivePrimeUtr() (r []gffio.GffRecord, exists bool) {
	v := m.five_prime_utr
	if v == nil {
		return
	}
	return *v, true
}

// OldFivePrimeUtr returns the old "five_prime_utr" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldFivePrimeUtr(ctx context.Context) (v []gffio.GffRecord, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFivePrimeUtr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFivePrimeUtr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFivePrimeUtr: %w", err)
	}
	return oldValue.FivePrimeUtr, nil
}

// AppendFivePrimeUtr adds gr to the "five_prime_utr" field.
func (m *TranscriptMutation) AppendFivePrimeUtr(gr []gffio.GffRecord) {
	m.appendfive_prime_utr = append(m.appendfive_prime_utr, gr...)
}

// AppendedFivePrimeUtr returns the list of values that were appended to the "five_prime_utr" field in this mutation.
func (m *TranscriptMutation) AppendedFivePrimeUtr() ([]gffio.GffRecord, bool) {
	if len(m.appendfive_prime_utr) == 0 {
		return nil, false
	}
	return m.appendfive_prime_utr, true
}

// ResetFivePrimeUtr resets all changes to the "five_prime_utr" field.
func (m *TranscriptMutation) ResetFivePrimeUtr() {
	m.five_prime_utr = nil
	m.appendfive_prime_utr = nil
}

// SetThreePrimeUtr sets the "three_prime_utr" field.
func (m *TranscriptMutation) SetThreePrimeUtr(gr []gffio.GffRecord) {
	m.three_prime_utr = &gr
	m.appendthree_prime_utr = nil
}

// ThreePrimeUtr returns the value of the "three_prime_utr" field in the mutation.
func (m *TranscriptMutation) ThreePrimeUtr() (r []gffio.GffRecord, exists bool) {
	v := m.three_prime_utr
	if v == nil {
		return
	}
	return *v, true
}

// OldThreePrimeUtr returns the old "three_prime_utr" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldThreePrimeUtr(ctx context.Context) (v []gffio.GffRecord, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreePrimeUtr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreePrimeUtr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreePrimeUtr: %w", err)
	}
	return oldValue.ThreePrimeUtr, nil
}

// AppendThreePrimeUtr adds gr to the "three_prime_utr" field.
func (m *TranscriptMutation) AppendThreePrimeUtr(gr []gffio.GffRecord) {
	m.appendthree_prime_utr = append(m.appendthree_prime_utr, gr...)
}

// AppendedThreePrimeUtr returns the list of values that were appended to the "three_prime_utr" field in this mutation.
func (m *TranscriptMutation) AppendedThreePrimeUtr() ([]gffio.GffRecord, bool) {
	if len(m.appendthree_prime_utr) == 0 {
		return nil, false
	}
	return m.appendthree_prime_utr, true
}

// ResetThreePrimeUtr resets all changes to the "three_prime_utr" field.
func (m *TranscriptMutation) ResetThreePrimeUtr() {
	m.three_prime_utr = nil
	m.appendthree_prime_utr = nil
}

// SetCds sets the "cds" field.
func (m *TranscriptMutation) SetCds(gr []gffio.GffRecord) {
	m.cds = &gr
	m.appendcds = nil
}

// Cds returns the value of the "cds" field in the mutation.
func (m *TranscriptMutation) Cds() (r []gffio.GffRecord, exists bool) {
	v := m.cds
	if v == nil {
		return
	}
	return *v, true
}

// OldCds returns the old "cds" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldCds(ctx context.Context) (v []gffio.GffRecord, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCds: %w", err)
	}
	return oldValue.Cds, nil
}

// AppendCds adds gr to the "cds" field.
func (m *TranscriptMutation) AppendCds(gr []gffio.GffRecord) {
	m.appendcds = append(m.appendcds, gr...)
}

// AppendedCds returns the list of values that were appended to the "cds" field in this mutation.
func (m *TranscriptMutation) AppendedCds() ([]gffio.GffRecord, bool) {
	if len(m.appendcds) == 0 {
		return nil, false
	}
	return m.appendcds, true
}

// ResetCds resets all changes to the "cds" field.
func (m *TranscriptMutation) ResetCds() {
	m.cds = nil
	m.appendcds = nil
}

// SetGenomicSequence sets the "genomic_sequence" field.
func (m *TranscriptMutation) SetGenomicSequence(s string) {
	m.genomic_sequence = &s
}

// GenomicSequence returns the value of the "genomic_sequence" field in the mutation.
func (m *TranscriptMutation) GenomicSequence() (r string, exists bool) {
	v := m.genomic_sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldGenomicSequence returns the old "genomic_sequence" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldGenomicSequence(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenomicSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenomicSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenomicSequence: %w", err)
	}
	return oldValue.GenomicSequence, nil
}

// ResetGenomicSequence resets all changes to the "genomic_sequence" field.
func (m *TranscriptMutation) ResetGenomicSequence() {
	m.genomic_sequence = nil
}

// SetExonSequence sets the "exon_sequence" field.
func (m *TranscriptMutation) SetExonSequence(s string) {
	m.exon_sequence = &s
}

// ExonSequence returns the value of the "exon_sequence" field in the mutation.
func (m *TranscriptMutation) ExonSequence() (r string, exists bool) {
	v := m.exon_sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldExonSequence returns the old "exon_sequence" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldExonSequence(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExonSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExonSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExonSequence: %w", err)
	}
	return oldValue.ExonSequence, nil
}

// ResetExonSequence resets all changes to the "exon_sequence" field.
func (m *TranscriptMutation) ResetExonSequence() {
	m.exon_sequence = nil
}

// SetCdsSequence sets the "cds_sequence" field.
func (m *TranscriptMutation) SetCdsSequence(s string) {
	m.cds_sequence = &s
}

// CdsSequence returns the value of the "cds_sequence" field in the mutation.
func (m *TranscriptMutation) CdsSequence() (r string, exists bool) {
	v := m.cds_sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldCdsSequence returns the old "cds_sequence" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldCdsSequence(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCdsSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCdsSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCdsSequence: %w", err)
	}
	return oldValue.CdsSequence, nil
}

// ResetCdsSequence resets all changes to the "cds_sequence" field.
func (m *TranscriptMutation) ResetCdsSequence() {
	m.cds_sequence = nil
}

// SetProteinSequence sets the "protein_sequence" field.
func (m *TranscriptMutation) SetProteinSequence(s string) {
	m.protein_sequence = &s
}

// ProteinSequence returns the value of the "protein_sequence" field in the mutation.
func (m *TranscriptMutation) ProteinSequence() (r string, exists bool) {
	v := m.protein_sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldProteinSequence returns the old "protein_sequence" field's value of the Transcript entity.
// If the Transcript object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TranscriptMutation) OldProteinSequence(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProteinSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProteinSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProteinSequence: %w", err)
	}
	return oldValue.ProteinSequence, nil
}

// ResetProteinSequence resets all changes to the "protein_sequence" field.
func (m *TranscriptMutation) ResetProteinSequence() {
	m.protein_sequence = nil
}

// SetLocusID sets the "locus" edge to the Locus entity by id.
func (m *TranscriptMutation) SetLocusID(id string) {
	m.locus = &id
}

// ClearLocus clears the "locus" edge to the Locus entity.
func (m *TranscriptMutation) ClearLocus() {
	m.clearedlocus = true
}

// LocusCleared reports if the "locus" edge to the Locus entity was cleared.
func (m *TranscriptMutation) LocusCleared() bool {
	return m.clearedlocus
}

// LocusID returns the "locus" edge ID in the mutation.
func (m *TranscriptMutation) LocusID() (id string, exists bool) {
	if m.locus != nil {
		return *m.locus, true
	}
	return
}

// LocusIDs returns the "locus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocusID instead. It exists only for internal usage by the builders.
func (m *TranscriptMutation) LocusIDs() (ids []string) {
	if id := m.locus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocus resets all changes to the "locus" edge.
func (m *TranscriptMutation) ResetLocus() {
	m.locus = nil
	m.clearedlocus = false
}

// AddGotermIDs adds the "goterms" edge to the GoTerm entity by ids.
func (m *TranscriptMutation) AddGotermIDs(ids ...string) {
	if m.goterms == nil {
		m.goterms = make(map[string]struct{})
	}
	for i := range ids {
		m.goterms[ids[i]] = struct{}{}
	}
}

// ClearGoterms clears the "goterms" edge to the GoTerm entity.
func (m *TranscriptMutation) ClearGoterms() {
	m.clearedgoterms = true
}

// GotermsCleared reports if the "goterms" edge to the GoTerm entity was cleared.
func (m *TranscriptMutation) GotermsCleared() bool {
	return m.clearedgoterms
}

// RemoveGotermIDs removes the "goterms" edge to the GoTerm entity by IDs.
func (m *TranscriptMutation) RemoveGotermIDs(ids ...string) {
	if m.removedgoterms == nil {
		m.removedgoterms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.goterms, ids[i])
		m.removedgoterms[ids[i]] = struct{}{}
	}
}

// RemovedGoterms returns the removed IDs of the "goterms" edge to the GoTerm entity.
func (m *TranscriptMutation) RemovedGotermsIDs() (ids []string) {
	for id := range m.removedgoterms {
		ids = append(ids, id)
	}
	return
}

// GotermsIDs returns the "goterms" edge IDs in the mutation.
func (m *TranscriptMutation) GotermsIDs() (ids []string) {
	for id := range m.goterms {
		ids = append(ids, id)
	}
	return
}

// ResetGoterms resets all changes to the "goterms" edge.
func (m *TranscriptMutation) ResetGoterms() {
	m.goterms = nil
	m.clearedgoterms = false
	m.removedgoterms = nil
}

// AddDomainIDs adds the "domains" edge to the DomainAnnotation entity by ids.
func (m *TranscriptMutation) AddDomainIDs(ids ...string) {
	if m.domains == nil {
		m.domains = make(map[string]struct{})
	}
	for i := range ids {
		m.domains[ids[i]] = struct{}{}
	}
}

// ClearDomains clears the "domains" edge to the DomainAnnotation entity.
func (m *TranscriptMutation) ClearDomains() {
	m.cleareddomains = true
}

// DomainsCleared reports if the "domains" edge to the DomainAnnotation entity was cleared.
func (m *TranscriptMutation) DomainsCleared() bool {
	return m.cleareddomains
}

// RemoveDomainIDs removes the "domains" edge to the DomainAnnotation entity by IDs.
func (m *TranscriptMutation) RemoveDomainIDs(ids ...string) {
	if m.removeddomains == nil {
		m.removeddomains = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.domains, ids[i])
		m.removeddomains[ids[i]] = struct{}{}
	}
}

// RemovedDomains returns the removed IDs of the "domains" edge to the DomainAnnotation entity.
func (m *TranscriptMutation) RemovedDomainsIDs() (ids []string) {
	for id := range m.removeddomains {
		ids = append(ids, id)
	}
	return
}

// DomainsIDs returns the "domains" edge IDs in the mutation.
func (m *TranscriptMutation) DomainsIDs() (ids []string) {
	for id := range m.domains {
		ids = append(ids, id)
	}
	return
}

// ResetDomains resets all changes to the "domains" edge.
func (m *TranscriptMutation) ResetDomains() {
	m.domains = nil
	m.cleareddomains = false
	m.removeddomains = nil
}

// Where appends a list predicates to the TranscriptMutation builder.
func (m *TranscriptMutation) Where(ps ...predicate.Transcript) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TranscriptMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transcript).
func (m *TranscriptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TranscriptMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.seqname != nil {
		fields = append(fields, transcript.FieldSeqname)
	}
	if m.strand != nil {
		fields = append(fields, transcript.FieldStrand)
	}
	if m._type != nil {
		fields = append(fields, transcript.FieldType)
	}
	if m.source != nil {
		fields = append(fields, transcript.FieldSource)
	}
	if m.start != nil {
		fields = append(fields, transcript.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, transcript.FieldEnd)
	}
	if m.exon != nil {
		fields = append(fields, transcript.FieldExon)
	}
	if m.five_prime_utr != nil {
		fields = append(fields, transcript.FieldFivePrimeUtr)
	}
	if m.three_prime_utr != nil {
		fields = append(fields, transcript.FieldThreePrimeUtr)
	}
	if m.cds != nil {
		fields = append(fields, transcript.FieldCds)
	}
	if m.genomic_sequence != nil {
		fields = append(fields, transcript.FieldGenomicSequence)
	}
	if m.exon_sequence != nil {
		fields = append(fields, transcript.FieldExonSequence)
	}
	if m.cds_sequence != nil {
		fields = append(fields, transcript.FieldCdsSequence)
	}
	if m.protein_sequence != nil {
		fields = append(fields, transcript.FieldProteinSequence)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TranscriptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transcript.FieldSeqname:
		return m.Seqname()
	case transcript.FieldStrand:
		return m.Strand()
	case transcript.FieldType:
		return m.GetType()
	case transcript.FieldSource:
		return m.Source()
	case transcript.FieldStart:
		return m.Start()
	case transcript.FieldEnd:
		return m.End()
	case transcript.FieldExon:
		return m.Exon()
	case transcript.FieldFivePrimeUtr:
		return m.FivePrimeUtr()
	case transcript.FieldThreePrimeUtr:
		return m.ThreePrimeUtr()
	case transcript.FieldCds:
		return m.Cds()
	case transcript.FieldGenomicSequence:
		return m.GenomicSequence()
	case transcript.FieldExonSequence:
		return m.ExonSequence()
	case transcript.FieldCdsSequence:
		return m.CdsSequence()
	case transcript.FieldProteinSequence:
		return m.ProteinSequence()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TranscriptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transcript.FieldSeqname:
		return m.OldSeqname(ctx)
	case transcript.FieldStrand:
		return m.OldStrand(ctx)
	case transcript.FieldType:
		return m.OldType(ctx)
	case transcript.FieldSource:
		return m.OldSource(ctx)
	case transcript.FieldStart:
		return m.OldStart(ctx)
	case transcript.FieldEnd:
		return m.OldEnd(ctx)
	case transcript.FieldExon:
		return m.OldExon(ctx)
	case transcript.FieldFivePrimeUtr:
		return m.OldFivePrimeUtr(ctx)
	case transcript.FieldThreePrimeUtr:
		return m.OldThreePrimeUtr(ctx)
	case transcript.FieldCds:
		return m.OldCds(ctx)
	case transcript.FieldGenomicSequence:
		return m.OldGenomicSequence(ctx)
	case transcript.FieldExonSequence:
		return m.OldExonSequence(ctx)
	case transcript.FieldCdsSequence:
		return m.OldCdsSequence(ctx)
	case transcript.FieldProteinSequence:
		return m.OldProteinSequence(ctx)
	}
	return nil, fmt.Errorf("unknown Transcript field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TranscriptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transcript.FieldSeqname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqname(v)
		return nil
	case transcript.FieldStrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrand(v)
		return nil
	case transcript.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transcript.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case transcript.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case transcript.FieldEnd:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case transcript.FieldExon:
		v, ok := value.([]gffio.GffRecord)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExon(v)
		return nil
	case transcript.FieldFivePrimeUtr:
		v, ok := value.([]gffio.GffRecord)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFivePrimeUtr(v)
		return nil
	case transcript.FieldThreePrimeUtr:
		v, ok := value.([]gffio.GffRecord)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreePrimeUtr(v)
		return nil
	case transcript.FieldCds:
		v, ok := value.([]gffio.GffRecord)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCds(v)
		return nil
	case transcript.FieldGenomicSequence:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenomicSequence(v)
		return nil
	case transcript.FieldExonSequence:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExonSequence(v)
		return nil
	case transcript.FieldCdsSequence:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCdsSequence(v)
		return nil
	case transcript.FieldProteinSequence:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProteinSequence(v)
		return nil
	}
	return fmt.Errorf("unknown Transcript field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TranscriptMutation) AddedFields() []string {
	var fields []string
	if m.addstart != nil {
		fields = append(fields, transcript.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, transcript.FieldEnd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TranscriptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transcript.FieldStart:
		return m.AddedStart()
	case transcript.FieldEnd:
		return m.AddedEnd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TranscriptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transcript.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case transcript.FieldEnd:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	}
	return fmt.Errorf("unknown Transcript numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TranscriptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TranscriptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TranscriptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Transcript nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TranscriptMutation) ResetField(name string) error {
	switch name {
	case transcript.FieldSeqname:
		m.ResetSeqname()
		return nil
	case transcript.FieldStrand:
		m.ResetStrand()
		return nil
	case transcript.FieldType:
		m.ResetType()
		return nil
	case transcript.FieldSource:
		m.ResetSource()
		return nil
	case transcript.FieldStart:
		m.ResetStart()
		return nil
	case transcript.FieldEnd:
		m.ResetEnd()
		return nil
	case transcript.FieldExon:
		m.ResetExon()
		return nil
	case transcript.FieldFivePrimeUtr:
		m.ResetFivePrimeUtr()
		return nil
	case transcript.FieldThreePrimeUtr:
		m.ResetThreePrimeUtr()
		return nil
	case transcript.FieldCds:
		m.ResetCds()
		return nil
	case transcript.FieldGenomicSequence:
		m.ResetGenomicSequence()
		return nil
	case transcript.FieldExonSequence:
		m.ResetExonSequence()
		return nil
	case transcript.FieldCdsSequence:
		m.ResetCdsSequence()
		return nil
	case transcript.FieldProteinSequence:
		m.ResetProteinSequence()
		return nil
	}
	return fmt.Errorf("unknown Transcript field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TranscriptMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.locus != nil {
		edges = append(edges, transcript.EdgeLocus)
	}
	if m.goterms != nil {
		edges = append(edges, transcript.EdgeGoterms)
	}
	if m.domains != nil {
		edges = append(edges, transcript.EdgeDomains)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TranscriptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transcript.EdgeLocus:
		if id := m.locus; id != nil {
			return []ent.Value{*id}
		}
	case transcript.EdgeGoterms:
		ids := make([]ent.Value, 0, len(m.goterms))
		for id := range m.goterms {
			ids = append(ids, id)
		}
		return ids
	case transcript.EdgeDomains:
		ids := make([]ent.Value, 0, len(m.domains))
		for id := range m.domains {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TranscriptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedgoterms != nil {
		edges = append(edges, transcript.EdgeGoterms)
	}
	if m.removeddomains != nil {
		edges = append(edges, transcript.EdgeDomains)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TranscriptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transcript.EdgeGoterms:
		ids := make([]ent.Value, 0, len(m.removedgoterms))
		for id := range m.removedgoterms {
			ids = append(ids, id)
		}
		return ids
	case transcript.EdgeDomains:
		ids := make([]ent.Value, 0, len(m.removeddomains))
		for id := range m.removeddomains {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TranscriptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedlocus {
		edges = append(edges, transcript.EdgeLocus)
	}
	if m.clearedgoterms {
		edges = append(edges, transcript.EdgeGoterms)
	}
	if m.cleareddomains {
		edges = append(edges, transcript.EdgeDomains)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TranscriptMutation) EdgeCleared(name string) bool {
	switch name {
	case transcript.EdgeLocus:
		return m.clearedlocus
	case transcript.EdgeGoterms:
		return m.clearedgoterms
	case transcript.EdgeDomains:
		return m.cleareddomains
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TranscriptMutation) ClearEdge(name string) error {
	switch name {
	case transcript.EdgeLocus:
		m.ClearLocus()
		return nil
	}
	return fmt.Errorf("unknown Transcript unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TranscriptMutation) ResetEdge(name string) error {
	switch name {
	case transcript.EdgeLocus:
		m.ResetLocus()
		return nil
	case transcript.EdgeGoterms:
		m.ResetGoterms()
		return nil
	case transcript.EdgeDomains:
		m.ResetDomains()
		return nil
	}
	return fmt.Errorf("unknown Transcript edge %s", name)
}
