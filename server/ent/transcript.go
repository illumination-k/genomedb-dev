// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"genomedb/ent/gene"
	"genomedb/ent/transcript"
	"strings"

	"entgo.io/ent/dialect/sql"
)

// Transcript is the model entity for the Transcript schema.
type Transcript struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// Strand holds the value of the "strand" field.
	Strand string `json:"strand,omitempty"`
	// Type holds the value of the "type" field.
	Type string `json:"type,omitempty"`
	// GenomeSeq holds the value of the "genome_seq" field.
	GenomeSeq string `json:"genome_seq,omitempty"`
	// TranscriptSeq holds the value of the "transcript_seq" field.
	TranscriptSeq string `json:"transcript_seq,omitempty"`
	// CdsSeq holds the value of the "cds_seq" field.
	CdsSeq string `json:"cds_seq,omitempty"`
	// ProteinSeq holds the value of the "protein_seq" field.
	ProteinSeq string `json:"protein_seq,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the TranscriptQuery when eager-loading is set.
	Edges            TranscriptEdges `json:"edges"`
	gene_transcripts *string
}

// TranscriptEdges holds the relations/edges for other nodes in the graph.
type TranscriptEdges struct {
	// Gene holds the value of the gene edge.
	Gene *Gene `json:"gene,omitempty"`
	// Cds holds the value of the cds edge.
	Cds []*Cds `json:"cds,omitempty"`
	// Exon holds the value of the exon edge.
	Exon []*Exon `json:"exon,omitempty"`
	// FivePrimeUtr holds the value of the five_prime_utr edge.
	FivePrimeUtr []*FivePrimeUtr `json:"five_prime_utr,omitempty"`
	// ThreePrimeUtr holds the value of the three_prime_utr edge.
	ThreePrimeUtr []*ThreePrimeUtr `json:"three_prime_utr,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [5]bool
}

// GeneOrErr returns the Gene value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e TranscriptEdges) GeneOrErr() (*Gene, error) {
	if e.loadedTypes[0] {
		if e.Gene == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: gene.Label}
		}
		return e.Gene, nil
	}
	return nil, &NotLoadedError{edge: "gene"}
}

// CdsOrErr returns the Cds value or an error if the edge
// was not loaded in eager-loading.
func (e TranscriptEdges) CdsOrErr() ([]*Cds, error) {
	if e.loadedTypes[1] {
		return e.Cds, nil
	}
	return nil, &NotLoadedError{edge: "cds"}
}

// ExonOrErr returns the Exon value or an error if the edge
// was not loaded in eager-loading.
func (e TranscriptEdges) ExonOrErr() ([]*Exon, error) {
	if e.loadedTypes[2] {
		return e.Exon, nil
	}
	return nil, &NotLoadedError{edge: "exon"}
}

// FivePrimeUtrOrErr returns the FivePrimeUtr value or an error if the edge
// was not loaded in eager-loading.
func (e TranscriptEdges) FivePrimeUtrOrErr() ([]*FivePrimeUtr, error) {
	if e.loadedTypes[3] {
		return e.FivePrimeUtr, nil
	}
	return nil, &NotLoadedError{edge: "five_prime_utr"}
}

// ThreePrimeUtrOrErr returns the ThreePrimeUtr value or an error if the edge
// was not loaded in eager-loading.
func (e TranscriptEdges) ThreePrimeUtrOrErr() ([]*ThreePrimeUtr, error) {
	if e.loadedTypes[4] {
		return e.ThreePrimeUtr, nil
	}
	return nil, &NotLoadedError{edge: "three_prime_utr"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Transcript) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case transcript.FieldID, transcript.FieldStrand, transcript.FieldType, transcript.FieldGenomeSeq, transcript.FieldTranscriptSeq, transcript.FieldCdsSeq, transcript.FieldProteinSeq:
			values[i] = new(sql.NullString)
		case transcript.ForeignKeys[0]: // gene_transcripts
			values[i] = new(sql.NullString)
		default:
			return nil, fmt.Errorf("unexpected column %q for type Transcript", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Transcript fields.
func (t *Transcript) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case transcript.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				t.ID = value.String
			}
		case transcript.FieldStrand:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field strand", values[i])
			} else if value.Valid {
				t.Strand = value.String
			}
		case transcript.FieldType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field type", values[i])
			} else if value.Valid {
				t.Type = value.String
			}
		case transcript.FieldGenomeSeq:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field genome_seq", values[i])
			} else if value.Valid {
				t.GenomeSeq = value.String
			}
		case transcript.FieldTranscriptSeq:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field transcript_seq", values[i])
			} else if value.Valid {
				t.TranscriptSeq = value.String
			}
		case transcript.FieldCdsSeq:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field cds_seq", values[i])
			} else if value.Valid {
				t.CdsSeq = value.String
			}
		case transcript.FieldProteinSeq:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field protein_seq", values[i])
			} else if value.Valid {
				t.ProteinSeq = value.String
			}
		case transcript.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field gene_transcripts", values[i])
			} else if value.Valid {
				t.gene_transcripts = new(string)
				*t.gene_transcripts = value.String
			}
		}
	}
	return nil
}

// QueryGene queries the "gene" edge of the Transcript entity.
func (t *Transcript) QueryGene() *GeneQuery {
	return (&TranscriptClient{config: t.config}).QueryGene(t)
}

// QueryCds queries the "cds" edge of the Transcript entity.
func (t *Transcript) QueryCds() *CdsQuery {
	return (&TranscriptClient{config: t.config}).QueryCds(t)
}

// QueryExon queries the "exon" edge of the Transcript entity.
func (t *Transcript) QueryExon() *ExonQuery {
	return (&TranscriptClient{config: t.config}).QueryExon(t)
}

// QueryFivePrimeUtr queries the "five_prime_utr" edge of the Transcript entity.
func (t *Transcript) QueryFivePrimeUtr() *FivePrimeUtrQuery {
	return (&TranscriptClient{config: t.config}).QueryFivePrimeUtr(t)
}

// QueryThreePrimeUtr queries the "three_prime_utr" edge of the Transcript entity.
func (t *Transcript) QueryThreePrimeUtr() *ThreePrimeUtrQuery {
	return (&TranscriptClient{config: t.config}).QueryThreePrimeUtr(t)
}

// Update returns a builder for updating this Transcript.
// Note that you need to call Transcript.Unwrap() before calling this method if this Transcript
// was returned from a transaction, and the transaction was committed or rolled back.
func (t *Transcript) Update() *TranscriptUpdateOne {
	return (&TranscriptClient{config: t.config}).UpdateOne(t)
}

// Unwrap unwraps the Transcript entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (t *Transcript) Unwrap() *Transcript {
	_tx, ok := t.config.driver.(*txDriver)
	if !ok {
		panic("ent: Transcript is not a transactional entity")
	}
	t.config.driver = _tx.drv
	return t
}

// String implements the fmt.Stringer.
func (t *Transcript) String() string {
	var builder strings.Builder
	builder.WriteString("Transcript(")
	builder.WriteString(fmt.Sprintf("id=%v, ", t.ID))
	builder.WriteString("strand=")
	builder.WriteString(t.Strand)
	builder.WriteString(", ")
	builder.WriteString("type=")
	builder.WriteString(t.Type)
	builder.WriteString(", ")
	builder.WriteString("genome_seq=")
	builder.WriteString(t.GenomeSeq)
	builder.WriteString(", ")
	builder.WriteString("transcript_seq=")
	builder.WriteString(t.TranscriptSeq)
	builder.WriteString(", ")
	builder.WriteString("cds_seq=")
	builder.WriteString(t.CdsSeq)
	builder.WriteString(", ")
	builder.WriteString("protein_seq=")
	builder.WriteString(t.ProteinSeq)
	builder.WriteByte(')')
	return builder.String()
}

// Transcripts is a parsable slice of Transcript.
type Transcripts []*Transcript

func (t Transcripts) config(cfg config) {
	for _i := range t {
		t[_i].config = cfg
	}
}
